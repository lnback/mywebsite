[{"categories":null,"content":"关于我 CTGU lnback 邮箱：lna1374@qq.com github：lnback 关于这个博客 心血来潮时更 作业/工作要求时更 不想成为咸鱼时更 ","date":"2020-12-21","objectID":"/about/about/:0:0","tags":null,"title":"关于我","uri":"/about/about/"},{"categories":["Golang"],"content":" go语言的两个亮点：一个是goroutine，一个就是channel。二者合体的典型应用CSP，就是大家认可的并行开发神器。 ","date":"2020-12-18","objectID":"/go%E8%AF%AD%E8%A8%80%E7%9A%84csp%E6%A8%A1%E5%9E%8B/:0:0","tags":["Go","并发"],"title":"Go语言的CSP模型","uri":"/go%E8%AF%AD%E8%A8%80%E7%9A%84csp%E6%A8%A1%E5%9E%8B/"},{"categories":["Golang"],"content":"1.1 什么是CSP？ CSP是Communicating Sequential Process的简称，中文可以叫做通信顺序进程，是一种并发编程模型，是一个很强大的并发数据模型，是上个世纪七十年代提出的，用于描述两个独立并发实体通过共享的通讯channel(管道)进行通信的并发模型。相对于Actor模型，CSP中channel是第一类对象，他不关注发送消息的实体，而关注与发送消息时使用的channel。 严格来说，CSP是一门形式语言，用于描述并发系统中的互动模式，也因此成为一众面向并发的编程语言的理论源头，并衍生出了Occam/Limbo/Golang 而具体到编程语言，如Golang，其实只用到了CSP的很小一部分，即理论中的Process/Channel(对应到语言中的goroutine/channel)。这两个并发原语之间没有从属关系，Process可以订阅任意个Channel，Channel也并不关心是哪个Process在利用它进行通信；Process围绕Channel进行读写，形成一套有序阻塞和可预测的并发模型。 ","date":"2020-12-18","objectID":"/go%E8%AF%AD%E8%A8%80%E7%9A%84csp%E6%A8%A1%E5%9E%8B/:1:0","tags":["Go","并发"],"title":"Go语言的CSP模型","uri":"/go%E8%AF%AD%E8%A8%80%E7%9A%84csp%E6%A8%A1%E5%9E%8B/"},{"categories":["Golang"],"content":"1.2 Golang CSP 与主流语言通过共享内存来进行并发控制方式不同，Go语言采用CSP模式。这是一种用于描述两个独立的并发实体通过共享的通讯Channel（管道）进行通信的并发模型。 Golang就是借用CSP模型的一些概念为之实现并发进行理论支持，其实从实际出发，Go语言并没有完全实现了CSP模型的所有理论，仅仅是借用了process和channel这两个概念。process在go语言上的表现就是goroutine，goroutine是实际并发执行的实体，每个实体之间利用channel实现数据共享。 Go语言的CSP模型是由协程goroutine和通道channel实现的： goroutine：是一种轻量线程，他不是操作系统的线程，而是将一个操作系统线程分段使用，通过调度器实现协作式调度。是一种绿色线程，微线程。 channel：类似于Unix的Pipe，用于协程之间通讯和同步。协程之间虽然解耦，但是他们和channel有着耦合。 ","date":"2020-12-18","objectID":"/go%E8%AF%AD%E8%A8%80%E7%9A%84csp%E6%A8%A1%E5%9E%8B/:2:0","tags":["Go","并发"],"title":"Go语言的CSP模型","uri":"/go%E8%AF%AD%E8%A8%80%E7%9A%84csp%E6%A8%A1%E5%9E%8B/"},{"categories":["Golang"],"content":"1.3 Channel goroutine和channel是Go语言并发编程的两大基石。goroutine用于执行并发任务，channel用于goroutine之间的同步、通信。 channel在goroutine间架起了一条管道，在管道里传输数据，实现goroutine间的通信，实现了goroutine之间的通信；由于它是线程安全的，所以用起来很方便；channel还提供“先进先出的特性”；他还能影响goroutine的阻塞和唤醒。 ","date":"2020-12-18","objectID":"/go%E8%AF%AD%E8%A8%80%E7%9A%84csp%E6%A8%A1%E5%9E%8B/:3:0","tags":["Go","并发"],"title":"Go语言的CSP模型","uri":"/go%E8%AF%AD%E8%A8%80%E7%9A%84csp%E6%A8%A1%E5%9E%8B/"},{"categories":["Golang"],"content":"1.3.1 channel实现CSP 使用原子函数、读写锁可以保证资源的共享访问安全，但使用channel更优雅。 channel字面意义是“通道”，类似于linux中的管道。声明channel的语法如下： chan T // 声明一个双向通道 chan \u003c- T //声明一个只能用于发送的单向通道 \u003c-chan T //声明一个只能用于接收的单向通道 单向通道的声明，用 \u003c- 来表示，它指明通道的方向。你只要明白，代码的书写顺序是从左到右就马上能掌握通道的方向是怎样的。 因为 channel 是一个引用类型，所以在它被初始化之前，它的值是 nil，channel 使用 make 函数进行初始化。可以向它传递一个 int 值，代表 channel 缓冲区的大小（容量），构造出来的是一个缓冲型的 channel；不传或传 0 的，构造的就是一个非缓冲型的 channel。 两者有一些差别：非缓冲型 channel 无法缓冲元素，对它的操作一定顺序是 “发送 -\u003e 接收 -\u003e 发送 -\u003e 接收 -\u003e ……”，如果想连续向一个非缓冲 chan 发送 2 个元素，并且没有接收的话，第一次一定会被阻塞；对于缓冲型 channel 的操作，则要 “宽松” 一些，毕竟是带了 “缓冲” 光环。 Channel 分为两种：带缓冲、不带缓冲。对不带缓冲的 channel 进行的操作实际上可以看作 “同步模式”，带缓冲的则称为 “异步模式”。 同步模式下，发送方和接收方要同步就绪，只有在两者都 ready 的情况下，数据才能在两者间传输（后面会看到，实际上就是内存拷贝）。否则，任意一方先行进行发送或接收操作，都会被挂起，等待另一方的出现才能被唤醒。 异步模式下，在缓冲槽可用的情况下（有剩余容量），发送和接收操作都可以顺利进行。否则，操作的一方（如写入）同样会被挂起，直到出现相反操作（如接收）才会被唤醒。 小结一下：同步模式下，必须要使发送方和接收方配对，操作才会成功，否则会被阻塞；异步模式下，缓冲槽要有剩余容量，操作才会成功，否则也会被阻塞。 ","date":"2020-12-18","objectID":"/go%E8%AF%AD%E8%A8%80%E7%9A%84csp%E6%A8%A1%E5%9E%8B/:3:1","tags":["Go","并发"],"title":"Go语言的CSP模型","uri":"/go%E8%AF%AD%E8%A8%80%E7%9A%84csp%E6%A8%A1%E5%9E%8B/"},{"categories":["Golang"],"content":"1.4 Goroutine Goroutine 是实际并发执行的实体，它底层是使用协程(coroutine)实现并发，coroutine是一种运行在用户态的用户线程，类似于 greenthread，go底层选择使用coroutine的出发点是因为，它具有以下特点： 用户空间 避免了内核态和用户态的切换导致的成本 可以由语言和框架层进行调度 更小的栈空间允许创建大量的实例 可以看到第二条 用户空间线程的调度不是由操作系统来完成的，像在java 1.3中使用的greenthread的是由JVM统一调度的(后java已经改为内核线程)，还有在ruby中的fiber(半协程) 是需要在重新中自己进行调度的，而goroutine是在golang层面提供了调度器，并且对网络IO库进行了封装，屏蔽了复杂的细节，对外提供统一的语法关键字支持，简化了并发程序编写的成本。 ","date":"2020-12-18","objectID":"/go%E8%AF%AD%E8%A8%80%E7%9A%84csp%E6%A8%A1%E5%9E%8B/:4:0","tags":["Go","并发"],"title":"Go语言的CSP模型","uri":"/go%E8%AF%AD%E8%A8%80%E7%9A%84csp%E6%A8%A1%E5%9E%8B/"},{"categories":["Golang"],"content":"1.5 Goroutine调度器 ","date":"2020-12-18","objectID":"/go%E8%AF%AD%E8%A8%80%E7%9A%84csp%E6%A8%A1%E5%9E%8B/:5:0","tags":["Go","并发"],"title":"Go语言的CSP模型","uri":"/go%E8%AF%AD%E8%A8%80%E7%9A%84csp%E6%A8%A1%E5%9E%8B/"},{"categories":["Nginx"],"content":"1.1 简单介绍一下Nginx？ Nginx是一款轻量级的Web服务器/反向代理服务器及电子邮件（IMAP/POP3）代理服务器。Nginx主要提供反向代理、负载均衡、动静分离（静态资源服务）等服务。 ","date":"2020-12-16","objectID":"/nginx/:0:0","tags":["服务器","Nginx"],"title":"Nginx介绍","uri":"/nginx/"},{"categories":["Nginx"],"content":"1.1.1 反向代理 谈到方向代理，就不得不提正向代理。无论是正向代理，还是反向代理，说到底，就是代理模式的衍生版本罢了。 正向代理：某些情况下，代理我们用户去访问服务器，需要用户手动的设置代理服务器的IP和端口号。正向代理一个常见的例子就是VPN； 反向代理：是用来代理服务器的，代理我们要访问的目标服务器。代理服务器接受请求，然后将请求转发给内部网络的服务器，并将从服务器上得到的结果返回给客户端，此时代理服务器对外就表现为一个服务器。 ","date":"2020-12-16","objectID":"/nginx/:1:0","tags":["服务器","Nginx"],"title":"Nginx介绍","uri":"/nginx/"},{"categories":["Nginx"],"content":"1.1.2 负载均衡 在高并发情况下需要使用，其原理就是讲并发请求分摊到多个服务器执行，减轻每台服务器的压力，多台服务器(集群)共同完成工作任务，从而提高了数据的吞吐量。 Nginx支持的weight轮询、ip_hash、fair、url_hash这四种负载均衡调度算法。 负载均衡相比于反向代理更侧重的是将请求分担到多台服务器上去，所以谈论负载均衡只有在提供某服务的服务器大于两台时才有意义。 ","date":"2020-12-16","objectID":"/nginx/:2:0","tags":["服务器","Nginx"],"title":"Nginx介绍","uri":"/nginx/"},{"categories":["Nginx"],"content":"1.1.3 动静分离 动静分离是让动态网站里的动态网页根据一定规则把不变的资源和经常变的资源区分开来，动静资源做好了拆分以后，我们就可以根据静态资源的特点将其做缓存操作，这就是网站静态化处理的核心思路。 1.2 为什么要用Nginx？ Nginx有以下5个优点： 高并发、高性能 可扩展性（模块化设计，第三方插件生态圈丰富） 高可靠性（可以在服务器上持续不间断的运行数年） 热部署（热部署指可以再不停止Nginx服务的情况下升级Nginx） BSD许可证（可以将源代码下载下来进行修改然后使用自己的版本） 1.3 Nginx的四个主要组成部分了解吗？ Nginx二进制可执行文件：由各模块源码编译出一个文件 nginx.conf：控制Nginx行为，配置文件。 access.log：记录每一天HTTP请求消息。 error.log：定位问题。 ","date":"2020-12-16","objectID":"/nginx/:3:0","tags":["服务器","Nginx"],"title":"Nginx介绍","uri":"/nginx/"},{"categories":["redis"],"content":"复制 本章将介绍2.8以前的老版复制功能和2.8以后的新版复制功能，讲解机制和优劣势。 在Redis中，用户可以通过执行SLAVEOF命令或者设置slaveof选项，让一个服务器去复制另一个服务器，我们称呼被复制的服务器为主服务器（master），而对主服务器进行复制的服务器则被称为从服务器（slave）。搞清楚关系，如果服务器A输入指令SLAVEOF，则A变成B的从服务器。 进行复制中的主从服务器双方的数据库将保存相同的数据，概念上将这种现象称作“数据库状态一致”，或者简称“一致”。比如，在主服务器上执行命令， 127.0.0.1:6379\u003e SET msg \"hello world\" OK 则同时可以在从服务器上获取msg键的值， 127.0.0.1:12345\u003e GET msg \"hello world\" ","date":"2020-12-15","objectID":"/7.%E5%A4%8D%E5%88%B6/:0:0","tags":["Redis","阅读"],"title":"《Redis设计与实现》（七）复制","uri":"/7.%E5%A4%8D%E5%88%B6/"},{"categories":["redis"],"content":"一、旧版复制 ","date":"2020-12-15","objectID":"/7.%E5%A4%8D%E5%88%B6/:1:0","tags":["Redis","阅读"],"title":"《Redis设计与实现》（七）复制","uri":"/7.%E5%A4%8D%E5%88%B6/"},{"categories":["redis"],"content":"1.1 旧版复制的实现 Redis的复制功能分为同步和命令传播两个操作： 同步操作用于将从服务器的数据库状态更新至主服务器当前所处的数据库状态： 命令传播操作则用于在主服务器的数据库状态被修改，导致主从服务器的数据库状态出现不一致时，让主从服务器的数据库重新回到一致状态 1.1.1 同步 从服务器对主服务器的同步操作需要通过向主服务器发送SYNC命令来完成，以下是SYNC命令的执行步骤： 从服务器向主服务器发送SYNC命令 主服务器收到后，执行BGSAVE命令，生成RDB文件，并使用缓冲区记录现在开始执行的所有命令。 将RDB文件发送给从服务器，从服务器收到后更新 主服务器将缓冲区的内容发送给从服务器，从服务器收到后更新。 BGSAVE命令会增加一个子进程，负责创建RDB文件 1.1.2 命令传播 主服务器会将自己执行的写命令，也即是造成主从服务器不一致的那条写命令，发送给服务器执行，当从服务器执行了相同的写命令之后，主从服务器将再次回到一致状态。 ","date":"2020-12-15","objectID":"/7.%E5%A4%8D%E5%88%B6/:1:1","tags":["Redis","阅读"],"title":"《Redis设计与实现》（七）复制","uri":"/7.%E5%A4%8D%E5%88%B6/"},{"categories":["redis"],"content":"1.2 旧版复制的缺陷 在Redis中，从服务器对主服务器的复制可以分为以下两种情况： 初次复制：从服务器以前没有复制过任何主服务器，或者要复制的主服务器和上一次复制的主服务器不同。 断线后重复制：处于命令传播阶段的主从服务器因为网络原因而中断了复制，但从服务器通过自动重连接重新连上了主服务器，并继续复制主服务器。 初次复制的效果挺好的，但是断线后重复制效率就很低。因为执行SYNC命令是非常消耗资源的行为 ","date":"2020-12-15","objectID":"/7.%E5%A4%8D%E5%88%B6/:1:2","tags":["Redis","阅读"],"title":"《Redis设计与实现》（七）复制","uri":"/7.%E5%A4%8D%E5%88%B6/"},{"categories":["redis"],"content":"二、新版复制 ","date":"2020-12-15","objectID":"/7.%E5%A4%8D%E5%88%B6/:2:0","tags":["Redis","阅读"],"title":"《Redis设计与实现》（七）复制","uri":"/7.%E5%A4%8D%E5%88%B6/"},{"categories":["redis"],"content":"2.1 新版复制功能的实现 Redis从2.8版本开始，使用PSYNC命令代替SYNC命令来执行复制时的同步操作 PSYNC命令具有完整同步性和部分重同步两种模式： 完整重同步用于初次复制，和SYNV命令完全一致 部分重同步，将断线后的命令发送给从服务器 要实现部分重同步，需要完成三个部分： 主服务器的复制偏移量和从服务器的复制偏移量 主服务器的复制积压缓冲区 服务器的运行ID 2.1.1 复制偏移量 主服务器和从服务器会分别维护一个复制偏移量： 主服务器每次向从服务器传播N个字节的数据时，就将自己的复制偏移量的值加上N 从服务器每次收到主服务器传播来的N个字节的数据时，就将自己的复制偏移量加上N 通过对比主从服务器的复制偏移量，程序可以很容易地知道主从服务器是否处于一致状态： 如果主从服务器处于一致状态，那么主从服务器两者的偏移量总是相同的。 相反，如果主从服务器两者的偏移量并不相同，那么说明主从服务器并未处于一致状态。 2.1.2 复制积压缓冲区 复制积压缓冲区是由主服务器维护的一个固定长度（fixed-size）先进先出（FIFO）队列，默认大小为1MB。当主服务器进行命令传播时，它不仅会将写命令发送给所有从服务器，还会将写命令入队到复制积压缓冲区里面。 与此同时，主服务器也会向积压缓冲区添加偏移量， 当服务器重新连接上主服务器时，从服务器会通过PSYNC命令将自己的复制偏移量offset发送给主服务器，主服务器会根据这个复制偏移量来决定对从服务器执行何种同步操作： offset偏移量之后的数据仍然存在于复制积压缓冲区中，主服务器执行部分重同步操作 反之，偏移量之后的数据已不存在于复制积压缓冲区，则执行完整重同步。 复制积压缓冲区作为一个限制性容器保证了复制的高效性： 如果断线时间短，错过的命令少，则直接调用偏移量为从服务器补上命令 反之，则直接完全重同步。 2.1.3 服务器运行ID 每个Redis服务器，不论主服务器还是从服务，都会有自己的运行ID，运行ID在服务器启动时自动生成，由40个随机的十六进制字符组成。 当从服务器对主服务器进行初次复制时，主服务器会将自己的运行ID传送给从服务器，而从服务器则会将这个运行ID保存起来。 当从服务器断线并重新连上一个主服务器时，从服务器将向当前连接的主服务器发送之前保存的运行ID： 如果ID相同，则表示之前同步的主服务器就是这个，执行部分重同步。 如果ID不同，则表明从服务器断线之前复制的主服务器并不是当前连接的这个主服务器，执行完整重同步操作。 ","date":"2020-12-15","objectID":"/7.%E5%A4%8D%E5%88%B6/:2:1","tags":["Redis","阅读"],"title":"《Redis设计与实现》（七）复制","uri":"/7.%E5%A4%8D%E5%88%B6/"},{"categories":["redis"],"content":"2.2 PSYNC命令的实现 PSYNC命令的调用方法有两种： 如果是初次复制，则从服务器发送PSYNC?-1命令，主动请求主服务器进行完整重同步。 如果已经复制过，则从服务器发送PSYNC\u003crunid\u003e\u003coffset\u003e命令。即：上一次复制的主服务器ID+当前的复制偏移量。 根据情况，接收到PSYNC命令的主服务器会向从服务器返回以下三种回复的其中一种： （1） 如果主服务器返回+FULLRESYNC \u003crunid\u003e \u003coffset\u003e回复，那么表示主服务器将与从服务器执行完整重同步操作。从服务器将ID保存起来，在下一次PSYNC命令时使用，同时将offset的值当做自己的初始化偏移量。 （2） 如果主服务器返回+CONTINUE回复，那么表示主服务器将与从服务器执行部分重同步操作，从服务器只要等着主服务器将自己缺少的那部分数据发送过来就可以了。 （3） 如果主服务器返回-ERR回复，那么表示主服务器的版本低于Redis2.8，它识别不了PSYNC命令，从服务器将向主服务器发送SYNC命令，并与主服务器执行完整同步操作。 ","date":"2020-12-15","objectID":"/7.%E5%A4%8D%E5%88%B6/:2:2","tags":["Redis","阅读"],"title":"《Redis设计与实现》（七）复制","uri":"/7.%E5%A4%8D%E5%88%B6/"},{"categories":["redis"],"content":"2.3 新版复制的完整流程 本节主要展示新版复制操作的全过程，假设主服务器IP地址为127.0.0.1端口号为6379，从服务器IP为127.0.0.1端口号12345. （1）设置主服务器地址和端口 当客户端向从服务器发送以下命令时： 127.0.0.1:12345\u003e SLAVEOF 127.0.0.1 6379 OK 从服务器首先要做的就是将客户端给定的主服务器IP地址127.0.0.1以及端口6379保存到服务器状态的masterhost属性和masterport属性里面： struct redisServer{ //... char *masterhost; int masterport; //... }; （2）建立套接字连接 从服务器将根据命令所设置的IP地址和端口，创建连向主服务器的套接字连接 此时，从服务器变为了主服务器的客户端。从服务器同时具备服务器和客户端的两个身份。 （3）发送PING命令 连接成功后，从服务器立马发送一个PING命令，主要作用是： 检查套接字读写是否正常 检查主服务器能否正常处理命令 回复有三种可能： 主服务器返回了命令回复，但从服务器不能再规定的时间内读出， 表明主从之间网络连接不佳。从服务器断开并重新创建连向主服务器的套接字。 主服务器返回一个错误，表示主服务器暂时无法处理请求（比如正在处理一个超时运行脚本），从服务器断开并重新创建连向主服务器的套接字。 从服务器收到PONG回复，表示主从之间连接正常。 （4）身份验证 收到pong的回复后，下一步是确定是否进行身份验证：如果从服务器设置了masterauth选项，那么进行身份验证；反之则不进行。 （5）发送端口信息 从服务器向主服务器发送从服务器的监听端口号。主服务器在接收到这个命令之后，会将端口号记录在从服务器所对应的客户端状态的slave_listening_port属性中： typedef struct redisClient { // ... // 从服务器的监听端口号 int slave_listening_port; // ... } redisClient; （6）同步 在这一步，从服务器将向主服务器发送PSYNC命令，执行同步操作，并将自己的数据库更新至主服务器数据库当前所处的状态。 在同步操作执行之前，只有从服务器是主服务器的客户端，但是在执行同步操作之后，主服务器也会成为从服务器的客户端。 （7）命令传播 主服务器只要一直将自己执行的写命令发送给从服务器，而从服务器只要一直接收并执行主服务器发来的写命令，就可以保证主从服务器一直保持一致了。 ","date":"2020-12-15","objectID":"/7.%E5%A4%8D%E5%88%B6/:2:3","tags":["Redis","阅读"],"title":"《Redis设计与实现》（七）复制","uri":"/7.%E5%A4%8D%E5%88%B6/"},{"categories":["redis"],"content":"三、心跳检测 在命令传播阶段，从服务器默认会以每秒一次的频率，向主服务器发送命令： REPLCONF ACK \u003creplication_offset\u003e 检测主从服务器的网络连接状态 辅助实现min-salves选项 检测命令丢失 ","date":"2020-12-15","objectID":"/7.%E5%A4%8D%E5%88%B6/:3:0","tags":["Redis","阅读"],"title":"《Redis设计与实现》（七）复制","uri":"/7.%E5%A4%8D%E5%88%B6/"},{"categories":["redis"],"content":"3.1 检测连接状态 如果主服务器超过一秒钟没有收到从服务器发来的REPLCONF ACK命令，那么主服务器就知道主从服务器之间的连接出现问题了 ","date":"2020-12-15","objectID":"/7.%E5%A4%8D%E5%88%B6/:3:1","tags":["Redis","阅读"],"title":"《Redis设计与实现》（七）复制","uri":"/7.%E5%A4%8D%E5%88%B6/"},{"categories":["redis"],"content":"3.2 辅助实现min-slaves选项 Redis的min-slaves-to-write和min-slaves-max-lag两个选项可以防止主服务器在不安全的情况下执行写命令 举个例子 min-slaves-to-write 3 min-slaves-max-lag 10 那么在 从服务器的数量少于3个，或者三个从服务器的延迟(lag)值都大于或等于10秒时，主服务器将拒绝执行命令。 ","date":"2020-12-15","objectID":"/7.%E5%A4%8D%E5%88%B6/:3:2","tags":["Redis","阅读"],"title":"《Redis设计与实现》（七）复制","uri":"/7.%E5%A4%8D%E5%88%B6/"},{"categories":["redis"],"content":"3.3 检测命令丢失 假如主服务器向从服务器传播的命令因为网络问题丢失，会导致二者偏移量不一致。这时心跳检测命令会侦察到这种情况，于是主服务器会补发。 ","date":"2020-12-15","objectID":"/7.%E5%A4%8D%E5%88%B6/:3:3","tags":["Redis","阅读"],"title":"《Redis设计与实现》（七）复制","uri":"/7.%E5%A4%8D%E5%88%B6/"},{"categories":["redis"],"content":"客户端和服务器 ","date":"2020-12-11","objectID":"/6.%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%92%8C%E6%9C%8D%E5%8A%A1%E5%99%A8/:0:0","tags":["Redis","阅读"],"title":"《Redis设计与实现》（六）客户端和服务器","uri":"/6.%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%92%8C%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"categories":["redis"],"content":"一、客户端 Redis服务器是典型的一对多服务器程序：一个服务器可以与多个客户端建立网络连接，处理他们的请求。 通过使用由I/O多路复用技术实现的文件事件处理器，Redis服务器使用单线程单进程的方式来处理命令请求，并与多个客户端进行网络通信。 对于每个与服务器进行连接的客户端，服务器都为这些客户端建立了相应的redis.h/redisClient结构（客户端状态），这个结构保存了客户端当前的状态信息。 在服务器中，用一个链表保存客户端的所有状态 struct redisServer { // ... // 一个链表，保存了所有客户端状态 list *clients; // ... }; ","date":"2020-12-11","objectID":"/6.%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%92%8C%E6%9C%8D%E5%8A%A1%E5%99%A8/:1:0","tags":["Redis","阅读"],"title":"《Redis设计与实现》（六）客户端和服务器","uri":"/6.%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%92%8C%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"categories":["redis"],"content":"1.1 客户端属性 （1）套接字描述符 客户端状态的fd属性记录了客户端正在使用的套接字描述符。根据客户端类型不同，fd的值可以是 -1或大于-1的整数 ： 伪客户端为-1：伪客户端用于处理的AOF文件或Lua脚本，而不是网络。 普通客户端为大于-1的整数。 执行CLIENT list命令会列出所有连接到服务器的普通客户端。 redis\u003e CLIENT list addr=127.0.0.1:53428 fd=6 name= age=1242 idle=0 ... addr=127.0.0.1:53469 fd=7 name= age=4 idle=4 ... （2）名字 默认情况下客户端是没有名字的，比如上面的例子中name处就是空白。使用CLIENT setname命令可以为客户端设置一个名字，让客户端的身份变得更清晰。 typedef struct redisClient { //... robj *name; //... }redisClient; 如果客户端没有名字，那么相应客户端状态的name属性指向NULL指针；相反，如果有名字，那么name属性将指向一个字符串对象。 （3）标志 客户端的标志属性flags记录了客户端的角色（role），以及客户端目前所处的状态： typedef struct redisClient { // ... int flags; // ... } redisClient; 比如REDIS_BLOCKED标志表示客户端正在被BRPOP、BLPOP等命令阻塞。flag可以是单个标志，也可以是多个标志的组合。比如： flags=REDIS_SLAVE | REDIS_PRE_PSYNC; （4）输入缓冲区 客户端状态的输入缓冲区用于保存客户端发送的命令请求： typedef struct redisClient { // ... sds querybuf; // ... } redisClient; 保存方式和AOF类似，比如SET key value被转化为如下的SDS值： *3\\r\\n$3\\r\\nSET\\r\\n$3\\r\\nkey\\r\\n$5\\r\\nvalue\\r\\n （5）命令与命令参数 在服务器将客户端发送的命令请求保存到客户端状态的querybuf属性之后，服务器将对命令请求的内容进行分析，并将得出的命令参数以及命令参数的个数分别保存到客户端状态的argv属性和argc属性： typedef struct redisClient { // ... robj **argv; int argc; // ... } redisClient; argv属性是一个数组，数组中的每个项都是一个字符串对象，其中argv[0]是要执行的命令，而之后的其他项则是传给命令的参数。 （6）命令的实现函数 当服务器从协议内容中分析并得出argv属性和argc属性的值之后，服务器将根据项argv[0]的值，在命令表中查找命令所对应的命令实现函数。 命令表是一个字典结构，键是SDS结构，保存了命令的名字，值是redisCommand结构，保存了： 实现函数 命令标志 命令的参数个数 命令的总执行次数 总消耗时长 当程序在命令表中成功找到argv[0]所对应的redisCommand结构时，客户端状态的cmd指针指向这个结构： typedef struct redisClient { // ... struct redisCommand *cmd; // ... } redisClient; 服务器就可以使用cmd属性所指向的redisCommand结构，以及argv、argc属性中保存的命令参数信息，调用命令实现函数，执行客户端指定的命令。 （7）输出缓冲区 命令回复会被保存在客户端状态的输出缓冲区里面，每个客户端都有两个输出缓冲区可用，一个缓冲区的大小是固定的，另一个缓冲区的大小是可变的： 固定大小的缓冲区用于保存那些长度比较小的回复，比如OK、简短的字符串值、整数值、错误回复等等。 可变大小的缓冲区用于保存那些长度比较大的回复，比如一个非常长的字符串值，一个由很多项组成的列表，一个包含了很多元素的集合等等。 （8）身份验证 客户端状态的authenticated属性用于记录客户端是否通过了身份验证： typedef struct redisClient { // ... int authenticated; // ... } redisClient; 为0表示没有通过验证，为1表示通过。如果没有通过，除了AUTH命令之外，客户端发送的所有其他命令都会被服务器拒绝执行。 redis\u003e SET msg \"hello world\" (error) NOAUTH Authentication required. 当客户端通过AUTH命令成功进行身份验证之后，客户端状态authenticated属性的值就会从0变为1. （9）时间 客户端还有几个和时间有关的属性： typedef struct redisClient { // ... time_t ctime; time_t lastinteraction; time_t obuf_soft_limit_reached_time; // ... } redisClient; ctime属性记录了创建客户端的时间，这个时间可以用来计算客户端与服务器已经连接了多少秒。 lastinteraction属性记录了客户端与服务器最后一次进行互动（interaction）的时间。（收或者发命令） obuf_soft_limit_reached_time属性记录了输出缓冲区第一次到达软性限制（soft limit）的时间 ","date":"2020-12-11","objectID":"/6.%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%92%8C%E6%9C%8D%E5%8A%A1%E5%99%A8/:1:1","tags":["Redis","阅读"],"title":"《Redis设计与实现》（六）客户端和服务器","uri":"/6.%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%92%8C%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"categories":["redis"],"content":"1.2 创建与关闭客户端 （1）普通客户端 所谓普通客户端是指客户端通过网络与服务器连接，客户端使用connect函数连接到服务器时就会调用连接事件处理器。 之后，会将新客户端的状态添加到clients链表的末尾。 关闭的原因可能有很多种 客户端进程退出或被杀死 客户端向服务器发送了带有不符合协议格式的命令请求 如果客户端成为了CLIENT KILL命令的目标 客户端空转超时 客户端发送的命令请求的大小超过了输入缓冲区的限制大小（默认为1 GB） 如果要发送给客户端的命令回复的大小超过了输出缓冲区的限制大小 除了超过1GB大小的硬性限制外，还有软性限制，用到了之前提到的obuf_soft_limit_reached_time属性。 如果输出缓冲区的大小超过了软性限制所设置的大小，但还没超过硬性限制，那么服务器将使用客户端状态结构的obuf_soft_limit_reached_time属性记录下客户端到达软性限制的起始时间。之后服务器会继续监视客户端，如果输出缓冲区的大小一直超出软性限制，并且持续时间超过服务器设定的时长，那么服务器将关闭客户端 （2）Lua脚本的伪客户端 服务器会在初始化时创建负责执行Lua脚本中包含的Redis命令的伪客户端，并将这个伪客户端关联在服务器状态结构的lua_client属性中： struct redisServer { // ... redisClient *lua_client; // ... }; Lua脚本会一直存在于服务器生命周期，只有服务器被关闭时他才会停止。 服务器在载入AOF文件时，会创建用于执行AOF文件包含的Redis命令的伪客户端，并在载入完成之后，关闭这个伪客户端。 ","date":"2020-12-11","objectID":"/6.%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%92%8C%E6%9C%8D%E5%8A%A1%E5%99%A8/:1:2","tags":["Redis","阅读"],"title":"《Redis设计与实现》（六）客户端和服务器","uri":"/6.%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%92%8C%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"categories":["redis"],"content":"二、服务器 ","date":"2020-12-11","objectID":"/6.%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%92%8C%E6%9C%8D%E5%8A%A1%E5%99%A8/:2:0","tags":["Redis","阅读"],"title":"《Redis设计与实现》（六）客户端和服务器","uri":"/6.%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%92%8C%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"categories":["redis"],"content":"2.1 命令请求的执行过程 在处理SET KEY VALUE的过程中，客户端和服务器共需要执行以下操作： 客户端向服务器发送命令请求SET KEY VALUE 服务器接收并处理，产生回复命令OK 服务器发送OK给客户端 客户端接收到命令，并打印给用户 （1）发送命令请求 用户在客户端键入一个请求时，客户端会将命令请求转换为协议格式，然后通过套接字发送给服务器。 （2）读取命令请求 当客户端与服务器之间的连接套接字因为客户端的写入而变得可读时，服务器将调用命令请求处理器来执行以下操作： 读取套接字中的协议请求，并保存在客户端状态的输入缓冲区内 分析命令，提取命令参数和个数，存在argv和argc属性中 调用命令执行器 （3）命令执行器 前面提到过，命令执行器会在命令表中查找命令，并将找到的结果保存在客户端状态cmd中。 字典的键是一个命令的字符串格式，值则是一个redisCommand结构： 下表展示了slags属性可以使用的标识和意义： 比如一个set操作就会： 现在已经成功完成了：连接所需函数，参数，参数个数。但在真正执行之前还需要进行检查： 检查客户端状态cmd是否指向NULL 根据redisCommand结构的arity属性，检查参数个数是否正确 检查身份验证 检查内存占用 如果当前客户端正在SUBSCRIBE命令订阅频道，则只接受订阅命令，其他命令会被拒绝。 服务器因Lua脚本超时并阻塞，服务器只会执行关闭命令，其他会被拒绝。 如果客户端正在执行事务，则服务器只会执行客户端发来的EXEC、DISCARD、MULTI、WATCH四个命令，其他命令都会被放进事务队列中。 如果打开了监视器功能，服务器会把将要执行的命令发送给监视器。 在执行命令时，先找到客户端状态指针client，然后找到命令字典cmd，然后查找命令的函数指针proc client-\u003ecmd-\u003eproc(client); 处理完毕后，产生回复，保存在输出缓冲区里面，之后实现函数还会为客户端的套接字关联命令回复处理器，这个处理器负责将命令回复返回给客户端。 ","date":"2020-12-11","objectID":"/6.%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%92%8C%E6%9C%8D%E5%8A%A1%E5%99%A8/:2:1","tags":["Redis","阅读"],"title":"《Redis设计与实现》（六）客户端和服务器","uri":"/6.%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%92%8C%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"categories":["redis"],"content":"2.2 severCron函数 Redis服务器中的serverCron函数默认每隔100毫秒执行一次，这个函数负责管理服务器的资源，并保持服务器自身的良好运转。severCorn函数的常见功能如下： （1）更新服务器时间缓存 Redis服务器中有不少功能需要获取系统的当前时间，而每次获取系统的当前时间都需要执行一次系统调用，为了减少系统调用的执行次数，服务器状态中的unixtime属性和mstime属性被用作当前时间的缓存： struct redisServer { // ... // 保存了秒级精度的系统当前UNIX时间戳 time_t unixtime; // 保存了毫秒级精度的系统当前UNIX时间戳 long long mstime; }; 因为serverCron函数默认会以每100毫秒一次的频率更新unixtime属性和mstime属性，所以这两个属性记录的时间的精确度并不高。 （2）更新LRU时钟 服务器状态中的lruclock属性保存了服务器的LRU时钟，这个属性和上面介绍的unixtime属性、mstime属性一样，都是服务器时间缓存的一种。 struct redisServer { // ... // 默认每10秒更新一次的时钟缓存， // 用于计算键的空转（idle）时长。 unsigned lruclock:22; //... }; 每个Redis对象都会有一个lru属性，这个lru属性保存了对象最后一次被命令访问的时间： typedef struct redisObject { // ... unsigned lru:22; // ... } robj; 当服务器要计算一个数据库键的空转时间（也即是数据库键对应的值对象的空转时间），程序会用服务器的lruclock属性记录的时间减去对象的lru属性记录的时间。 由于是10秒更新一次，所以时钟并不是实时的，这个LRU时间只是一个模糊的估算值。 （3）更新服务器每秒执行命令次数 serverCron函数中的trackOperationsPerSecond函数会以每100毫秒一次的频率执行，这个函数的功能是以抽样计算的方式，估算并记录服务器在最近一秒钟处理的命令请求数量。 trackOperationsPerSecond函数每次运行，都会根据ops_sec_last_sample_time记录的上一次抽样时间和服务器的当前时间，以及ops_sec_last_sample_ops记录的上一次抽样的已执行命令数量和服务器当前的已执行命令数量，计算出两次trackOperationsPerSecond调用之间，服务器平均每一毫秒处理了多少个命令请求，然后将这个平均值乘以1000，这就得到了服务器在一秒钟内能处理多少个命令请求的估计值，这个估计值会被作为一个新的数组项被放进ops_sec_samples环形数组里面。 （4）更新内存峰值记录 服务器状态中的stat_peak_memory属性记录了服务器的内存峰值大小： struct redisServer { // ... // 已使用内存峰值 size_t stat_peak_memory; // ... }; 每次serverCron函数执行时，程序都会查看服务器当前使用的内存数量，并与stat_peak_memory保存的数值进行比较，如果当前使用的内存数量比stat_peak_memory属性记录的值要大，那么就替换峰值。 （5）处理SIGTERM信号 在启动服务器时，Redis会为服务器进程的SIGTERM信号关联处理器sigtermHandler函数，这个信号处理器负责在服务器接到SIGTERM信号时，打开服务器状态的shutdown_asap标识。 每次serverCron函数运行时，程序都会对服务器状态的shutdown_asap属性进行检查，并根据属性的值决定是否关闭服务器。 （6）管理客户端资源 serverCron函数每次执行都会调用clientsCron函数，检查： 客户端服务器连接超时（长时间没有互动），程序将释放这个客户端。 客户端在上一次执行命令后，输入缓冲区大小超过一定长度，程序会释放客户端当前的输入缓冲区。 （7）管理数据库资源 serverCron函数每次执行都会调用databasesCron函数，这个函数会对服务器中的一部分数据库进行检查，删除其中的过期键，并在有需要时，对字典进行收缩操作。参见Redis中的定期检查 （8）执行被延迟的BGREWRITEAOF 在服务器执行BGSAVE命令的期间，如果客户端向服务器发来BGREWRITEAOF命令，那么服务器会将BGREWRITEAOF命令的执行时间延迟到BGSAVE命令执行完毕之后。 每次serverCron函数执行时，函数都会检查BGSAVE命令或者BGREWRITEAOF命令是否正在执行，如果这两个命令都没在执行，且有被延迟的BGREWRITEAOF，则执行。 （9）将AOF缓冲区内容写入AOF文件 （10）关闭输出缓冲区超限的客户端 （11）增加cronloops计数 服务器状态的cronloops属性记录了serverCron函数执行的次数，每执行一次就增加计数。作用是：在复制模块中实现“每执行serverCron函数N次就执行一次指定代码”的功能。 ","date":"2020-12-11","objectID":"/6.%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%92%8C%E6%9C%8D%E5%8A%A1%E5%99%A8/:2:2","tags":["Redis","阅读"],"title":"《Redis设计与实现》（六）客户端和服务器","uri":"/6.%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%92%8C%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"categories":["redis"],"content":"2.3 服务器初始化 服务器初始化要完成以下几个任务： 初始化服务器状态结构 载入配置选项 初始化服务器数据结构 还原数据库状态 执行时间循环 （1）初始化服务器状态结构 创建一个struct redisServer类型的实例变量server作为服务器的状态，并为结构中的各个属性设置默认值。 初始化server变量的工作由redis.c/initServerConfig函数完成，主要工作： 设置服务器ID 设置服务器运行默认频率 设置配置文件路径 设置运行架构 设置默认端口号 设置RDB持久化和AOF持久化条件 初始化LRU时钟 创建命令表 （2）载入配置选项 完成初始化服务器状态结构后 ，所有变量会被附上默认的值，但是实际上用户可能修改了某些参数。此时，载入用户的配置选项，替换掉那些被修改后的默认值。 （3）初始化服务器数据结构 除了在之前执行initServerConfig函数初始化server状态时，程序只创建了命令表一个数据结构，在这个阶段还需要创建其他数据结构： server.client链表，记录了所有与服务器相连的客户端状态结构。 server.db数组，数组中包含了所有数据库。 server.pubsub_channels字典，保存模式订阅信息的server.pubsub_patterns链表。 server.lua，用于执行Lua脚本的Lua环境 server.slowlog，用于保存慢查询日志。 服务器到现在才初始化数据结构的原因在于，服务器必须先载入用户指定的配置选项，然后才能正确地对数据结构进行初始化。 （4）还原数据库状态 在完成了对服务器状态server变量的初始化之后，服务器需要载入RDB文件或者AOF文件，并根据文件记录的内容来还原服务器的数据库状态。 如果启用了AOF持久化功能，则会使用AOF来还原，否则用RDB文件还原。 （5）执行事件循环 在初始化的最后一步，服务器将打印出以下日志： [5244] 21 Nov 22:43:49.084 * The server is now ready to accept connections on port 6379 开始执行事件循环，意味着服务器现在开始可以接受客户端的连接请求了。 ","date":"2020-12-11","objectID":"/6.%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%92%8C%E6%9C%8D%E5%8A%A1%E5%99%A8/:2:3","tags":["Redis","阅读"],"title":"《Redis设计与实现》（六）客户端和服务器","uri":"/6.%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%92%8C%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"categories":["Golang"],"content":"Go并发调度：G-P-M 模型 ","date":"2020-12-10","objectID":"/goroutine/:1:0","tags":["Go","并发"],"title":"Go语言的并发","uri":"/goroutine/"},{"categories":["Golang"],"content":"1. GPM模型 G：Goroutine的简称，上面用go关键字家函数调用的代码就是创建了一个G对象。 M：Machine的简称，代表一个线程，每次创建一个M的时候，都会有底层线程创建；所有的G任务，最终都是在M上执行。 P：代表一个处理器，每一个运行的M都必须绑定一个P，就像线程必须在一个CPU核上运行一样。 P的个数就是GOMAXPROCS（最大256），启动时固定的，一般不修改； M的个数和P的个数不一定一样多（会有休眠的M或者不需要太多的M）（最大10000）；每一个P保存着本地G任务队列，还有一个全局G任务队列； 全局G任务队列会和各个本地G任务队列按照一定的策略互相交换（满了，则把本地队列的一半送给全局队列） P是用一个全局数组（255）来保存的，并且维护着一个全局的P空闲链表 什么时候创建一个M：当用go创建一个新的goroutine时，即调用newProcess时，会检查是否有P，如果有就会为这个P找一个M，如果没有M，则会新建M。 ","date":"2020-12-10","objectID":"/goroutine/:1:1","tags":["Go","并发"],"title":"Go语言的并发","uri":"/goroutine/"},{"categories":["Golang"],"content":"2. 调度过程 假如我们有一个G(G1)已经通过P被安排到了一个M上正在执行，在G1执行的过程中我们又创建两个G，这两个G会被马上放入与Goroutine1相同的P的本地G任务队列中，排队等待与该P绑定的M的执行，这是最基本的结构，很好理解。 有几个问题： 如何在一个多核心系统上尽量分配G到多个M上运行，充分利用多核，提高并发能力？ 如果某个M在执行G的过程中被G中的系统调用阻塞了，怎么办？ 如果某一个G在M运行时间过长，有没有办法做抢占式调度，让该M上的其他G获得一定的运行时间，以保证调度系统的公平性? 第一个问题 如果我们在一个Goroutine中通过go关键字创建了大量G，这些G虽然暂时会被放在同一个队列, 但如果这时还有空闲P（系统内P的数量默认等于系统cpu核心数），Go运行时系统始终能保证至少有一个（通常也只有一个）活跃的M与空闲P绑定去各种G队列去寻找可运行的G任务，该种M称为自旋的M。 一般寻找顺序为：自己绑定的P的队列，全局队列，然后其他P队列。如果自己P队列找到就拿出来开始运行，否则去全局队列看看，由于全局队列需要锁保护，如果里面有很多任务，会转移一批到本地P队列中一次性转移(全局G个数/P个数），避免每次都去竞争锁。如果全局队列还是没有，就要开始玩狠的了，直接从其他P队列偷任务了（偷一半任务回来）。 这样就保证了在还有可运行的G任务的情况下，总有与CPU核心数相等的M+P组合 在执行G任务或在执行G的路上(寻找G任务)。 这里还有一个问题：M+P寻找空闲的G时，首先会以1/61的概率去从全局队列中获取G（避免饥饿），如果没有则从本地队列中寻找G，本地找不到就去全局中寻找（因为前面仅仅是1/61的概率） 第二个问题 在这种情况下，这个M将会被内核调度器调度出CPU并处于阻塞状态，与该M关联的其他G就没有办法继续执行了。 但Go运行时系统的一个监控线程(sysmon线程)能探测到这样的M，并把与该M绑定的P剥离，寻找其他空闲或新建M接管该P，然后继续运行其中的G，大致过程如下图所示。然后等到该M从阻塞状态恢复，需要重新找一个空闲P来继续执行原来的G，如果这时系统正好没有空闲的P，就把原来的G放到全局队列当中，等待其他M+P组合发掘并执行。 第三个问题 有一个线程sysmon，用来监控和管理，在内部是一个循环： 记录所有P的G任务技术schedtick（schedtick会在每执行一个G任务后递增） 如果检查到 schedtick一直没有递增，说明这个P一直在执行同一个G任务，如果超过一定的时间（10ms），就在这个G任务的栈信息里面加一个标记 然后这个G任务在执行的时候，如果遇到非内联函数调用，就会检查一次这个标记，然后中断自己，把自己加到队列末尾，执行下一个G。 如果没有遇到非内联函数（有时候正常的小函数会被优化成内联函数）调用的话，那就惨了，会一直执行这个G任务，直到它自己结束；如果是个死循环，并且GOMAXPROCS=1的话，会直接死机。 对于一个G任务，中断后的回复过程： 中断的时候将寄存器里的栈信息保存到自己的G对象里面。 当再次轮到自己执行的时候，将自己保存的栈信息复制到寄存器里面，就可以接着上次之后运行了。 ","date":"2020-12-10","objectID":"/goroutine/:1:2","tags":["Go","并发"],"title":"Go语言的并发","uri":"/goroutine/"},{"categories":["Golang"],"content":"3. 总结 goroutine是按照抢占式调度的，一个goroutine最多执行10ms就会换做下一个 这个和目前主流系统的cpu调度类似（按照时间分片） windows：20ms linux：5ms-800ms ","date":"2020-12-10","objectID":"/goroutine/:1:3","tags":["Go","并发"],"title":"Go语言的并发","uri":"/goroutine/"},{"categories":["redis"],"content":"事件 Redis是一个事件驱动程序，前面提到，服务器需要处理文件事件和时间事件。 文件事件：Redis服务器通过套接字与客户端（或者与其他Redis服务器）进行连接，而文本时间就是服务器对套接字操作的抽象。 时间事件：某些操作会在给定的时间点进行，对这类定时操作的的抽象就是时间事件。 ","date":"2020-12-09","objectID":"/5.%E4%BA%8B%E4%BB%B6/:0:0","tags":["Redis","阅读"],"title":"《Redis设计与实现》（五）事件","uri":"/5.%E4%BA%8B%E4%BB%B6/"},{"categories":["redis"],"content":"一、文件事件 Redis基于Reactor模式开发了自己的网络事件处理器：这个处理器被称为文件事件处理器。 Reactor模式用于高并发，依靠事件驱动。传统的线程连接中，IO连接后需要等待客户的请求。而事件驱动中，IO可以干别的事，等客户发来请求后再处理。 在Redis中， 文件事件处理器使用I/O多路复用（multiplexing）程序来同时监听多个套接字，并根据套接字目前执行的任务来为套接字关联不同的事件处理器。 当被监听的套接字准备好执行连接应答（accept）、读取（read）、写入（write）、关闭（close）等操作时，与操作相对应的文件事件就会产生，这时文件事件处理器就会调用套接字之前关联好的事件处理器来处理这些事件。 虽然文件事件处理器以单线程方式运行，但通过使用I/O多路复用程序来监听多个套接字，文件事件处理器既实现了高性能的网络通信模型，又可以很好地与Redis服务器中其他同样以单线程方式运行的模块进行对接，这保持了Redis内部单线程设计的简单性。 ","date":"2020-12-09","objectID":"/5.%E4%BA%8B%E4%BB%B6/:1:0","tags":["Redis","阅读"],"title":"《Redis设计与实现》（五）事件","uri":"/5.%E4%BA%8B%E4%BB%B6/"},{"categories":["redis"],"content":"1.1 构成 文件事件处理器的四个组成部分，它们分别是套接字、I/O多路复用程序、文件事件分派器（dispatcher），以及事件处理器。 前面提到，文件事件是对套接字操作的抽象，当一个套接字准备好后，就会产生一个文件事件。 尽管多个文件事件可能会并发地出现，但I/O多路复用程序总是会将所有产生事件的套接字都放到一个队列里面，然后通过这个队列，以有序（sequentially）、同步（synchronously）、每次一个套接字的方式向文件事件分派器传送套接字。只有当上一个套接字处理完毕后，复用程序才会向分派器传送下一个套接字。 ","date":"2020-12-09","objectID":"/5.%E4%BA%8B%E4%BB%B6/:1:1","tags":["Redis","阅读"],"title":"《Redis设计与实现》（五）事件","uri":"/5.%E4%BA%8B%E4%BB%B6/"},{"categories":["redis"],"content":"1.2 IO多路复用程序的实现 Redis的I/O多路复用程序的所有功能都是通过包装常见的select、epoll、evport和kqueue这些I/O多路复用函数库来实现的，每个I/O多路复用函数库在Redis源码中都对应一个单独的文件，比如ae_select.c、ae_epoll.c、ae_kqueue.c。 ae表示A simple event-driven programming library，一个简单的事件驱动程序库 由于IO复用程序提供了统一的接口，所以底层实现方法可以互换。 ","date":"2020-12-09","objectID":"/5.%E4%BA%8B%E4%BB%B6/:1:2","tags":["Redis","阅读"],"title":"《Redis设计与实现》（五）事件","uri":"/5.%E4%BA%8B%E4%BB%B6/"},{"categories":["redis"],"content":"1.3 事件类型 I/O多路复用程序可以同时监听多个套接字的ae.h/AE_READABLE和ae.h/AE_WRITABLE这两种事件，这两类事件和套接字操作之间的对应关系如下： 客户端对套接字执行write操作，客户端对服务器的监听套接字执行connect操作。此时套接字对服务器变为可读状态，就会产生AE_READABLE事件。 客户端对套接字执行read操作。此时套接字对服务器变为可写状态，就会产生AR_WRITABLE事件。 虽然是可以同时处理这两种事件，但优先处理可写事件。 ","date":"2020-12-09","objectID":"/5.%E4%BA%8B%E4%BB%B6/:1:3","tags":["Redis","阅读"],"title":"《Redis设计与实现》（五）事件","uri":"/5.%E4%BA%8B%E4%BB%B6/"},{"categories":["redis"],"content":"1.4 事件处理器 事件处理器有很多，最常用的是通信的连接应答处理器、命令请求处理器和命令回复处理器。 （1）连接应答处理器 networking.c/acceptTcpHandler函数是Redis的连接应答处理器，具体实现为sys/socket.h/accept函数的包装。 当Redis服务器进行初始化的时候，程序会将连接应答处理器和服务器监听套接字的AE_READABLE事件关联起来，当有客户端用sys/socket.h/connect函数连接服务器监听套接字的时候，套接字就会产生AE_READABLE事件，引发连接应答处理器执行。 （2）命令请求处理器 networking.c/readQueryFromClient函数是Redis的命令请求处理器，这个处理器负责从套接字中读入客户端发送的命令请求内容，具体实现为unistd.h/read函数的包装。 和上面一样，当客户端通过连接应答处理器成功连接到服务器后，服务器会将客户端套接字的AE_READABLE事件和命令请求处理器关联起来，当客户端向服务器发送命令请求的时候，套接字就会产生AE_READABLE事件，引发命令请求处理器执行。 （3）命令回复处理器 networking.c/sendReplyToClient函数是Redis的命令回复处理器，这个处理器负责将服务器执行命令后得到的命令通过套接字返回给客户端，具体实现为unistd.h/write函数的包装。 当服务器有命令回复需要传送给客户端的时候，服务器会将客户端套接字的AE_WRITABLE事件和命令回复处理器关联起来，当客户端准备好接收服务器传回的命令回复时，就会产生AE_WRITABLE事件，引发命令回复处理器执行。 ","date":"2020-12-09","objectID":"/5.%E4%BA%8B%E4%BB%B6/:1:4","tags":["Redis","阅读"],"title":"《Redis设计与实现》（五）事件","uri":"/5.%E4%BA%8B%E4%BB%B6/"},{"categories":["redis"],"content":"二、时间事件 Redis时间事件分为两类： 定时事件：程序在指定时间后执行一次。 周期性事件：每隔一段时间就执行，循环往复。 一个时间事件主要由以下三个属性组成： id：服务器为时间事件创造全局唯一ID作为识别，新事件比旧事件号码要大。 when：毫秒级UNIX时间戳，记录时间事件到达时间。 timeProc：时间事件处理器，到时间后处理事件。 ","date":"2020-12-09","objectID":"/5.%E4%BA%8B%E4%BB%B6/:2:0","tags":["Redis","阅读"],"title":"《Redis设计与实现》（五）事件","uri":"/5.%E4%BA%8B%E4%BB%B6/"},{"categories":["redis"],"content":"2.1 构成 服务器将所有时间事件都放在一个无序链表中，每当时间事件执行器运行时，它就遍历整个链表，查找所有已到达的时间事件，并调用相应的事件处理器。 因为新的事件总是放在表头，所以三个时间事件分别按逆序ID排列： 注意，我们说保存时间事件的链表为无序链表，指的不是“链表不按ID排序”，而是说，该链表不按when属性的大小排列。 ","date":"2020-12-09","objectID":"/5.%E4%BA%8B%E4%BB%B6/:2:1","tags":["Redis","阅读"],"title":"《Redis设计与实现》（五）事件","uri":"/5.%E4%BA%8B%E4%BB%B6/"},{"categories":["redis"],"content":"2.2 API ae.c/aeCreateTimeEvent函数接受一个毫秒数milliseconds和一个时间事件处理器proc作为参数，将一个新的时间事件添加到服务器。 ae.c/aeDeleteFileEvent函数接受一个时间事件ID作为参数，然后从服务器中删除该ID所对应的时间事件。 ae.c/aeSearchNearestTimer函数返回到达时间距离当前时间最接近的那个时间事件。 ae.c/processTimeEvents函数是时间事件的执行器，这个函数会遍历所有已到达的时间事件，并调用这些事件的处理器。已到达指的是，时间事件的when属性记录的UNIX时间戳等于或小于当前时间的UNIX时间戳。 ","date":"2020-12-09","objectID":"/5.%E4%BA%8B%E4%BB%B6/:2:2","tags":["Redis","阅读"],"title":"《Redis设计与实现》（五）事件","uri":"/5.%E4%BA%8B%E4%BB%B6/"},{"categories":["redis"],"content":"2.3 severCron函数 持续运行的Redis服务器需要定期对自身的资源和状态进行检查和调整，这些定期操作由redis.c/serverCron函数负责执行，它的主要工作包括： 更新服务器统计信息，包括事件、内存占用等情况 清理过期键值对 关闭和清理失效的客户端连接 AOF和RDB持久化操作 如果sever是主服务器，则对从服务器进行定期同步 如果是集群模式，对集群进行定期同步和连接测试 cron在unix中表示计划任务，计时程序。 默认频率是100毫秒一次，用户可以在redis.conf中修改hz选项来改变。 ","date":"2020-12-09","objectID":"/5.%E4%BA%8B%E4%BB%B6/:2:3","tags":["Redis","阅读"],"title":"《Redis设计与实现》（五）事件","uri":"/5.%E4%BA%8B%E4%BB%B6/"},{"categories":["redis"],"content":"2.4 事件的调度与执行 因为服务器中同时存在文件事件和时间事件两种事件类型，所以服务器必须对这两种事件进行调度，决定何时应该处理什么文件，以及花多少时间来处理它们等等。 事件的调度和执行由ae.c/aeProcessEvents函数负责。 对事件处理的原则是： 如果等待并处理完一次文件事件之后，仍未有任何时间事件到达，那么服务器将再次等待并处理文件事件。 对两种事件处理都是同步、有序、原子地执行的，服务器不会中途中断事件处理，也不会对事件进行抢占，因此需要尽可能地减少程序的阻塞时间，并在有需要时主动让出执行权。（比如写入字节太长，命令回复处理器就会break跳出，将余下的数据留到下次） 由于不能抢占，时间事件到达后需要等待文件事件处理完成，所以一般会稍晚于到达时间。 ","date":"2020-12-09","objectID":"/5.%E4%BA%8B%E4%BB%B6/:2:4","tags":["Redis","阅读"],"title":"《Redis设计与实现》（五）事件","uri":"/5.%E4%BA%8B%E4%BB%B6/"},{"categories":["redis"],"content":"持久化 ","date":"2020-12-09","objectID":"/4.%E6%8C%81%E4%B9%85%E5%8C%96/:0:0","tags":["Redis","阅读"],"title":"《Redis设计与实现》（四）持久化","uri":"/4.%E6%8C%81%E4%B9%85%E5%8C%96/"},{"categories":["redis"],"content":"一、RDB持久化 将服务器中的非空数据库以及它们的键值对统称为数据库状态。下图三个非空数据库，以及其中的键值对就是该服务器的数据库状态。 在Redis中，只有将数据保存在内存磁盘里才会永久保存，如果服务器进程退出，服务器中的数据库状态就会消失。为了解决这个问题，Redis提供了RDB持久化功能，这个功能可以将Redis在内存中的数据库状态保存到磁盘里面。 RDB持久化产生的RDB文件(Redis Database)是一个经过压缩的二进制文件，该文件可以被还原为数据库状态，所以即使服务器停机，服务器的数据还是被安全保存在硬盘中。 ","date":"2020-12-09","objectID":"/4.%E6%8C%81%E4%B9%85%E5%8C%96/:1:0","tags":["Redis","阅读"],"title":"《Redis设计与实现》（四）持久化","uri":"/4.%E6%8C%81%E4%B9%85%E5%8C%96/"},{"categories":["redis"],"content":"1.1 RDB文件的创建和载入 有两个Redis命令可以用于生成RDB文件，一个是SAVE，另一个是BGSAVE (BackGround SAVE)。SAVE命令会阻塞Redis服务器进程，直到RDB文件创建完毕为止，在服务器进程阻塞期间，服务器不能处理任何命令请求： redis\u003e SAVE //等待直到RDB文件创建完毕 OK 而BGSAVE命令会增加一个子进程，负责创建RDB文件。 redis\u003e BGSAVE //派生子进程，并由子进程创建RDB文件 Background saving started BGSAVE执行时，会阻止SAVE、其他BGSAVE和BGREWRITEAOF这三个命令执行，防止竞争。 创建RDB文件的实际工作由rdb.c/rdbSave函数完成，SAVE命令和BGSAVE命令会以不同的方式调用这个函数。 Redis并没有载入RDB文件的命令，只要服务器启动时检测到RDB文件存在，他就会自动载入。 比如下面日志的第二条： ","date":"2020-12-09","objectID":"/4.%E6%8C%81%E4%B9%85%E5%8C%96/:1:1","tags":["Redis","阅读"],"title":"《Redis设计与实现》（四）持久化","uri":"/4.%E6%8C%81%E4%B9%85%E5%8C%96/"},{"categories":["redis"],"content":"1.2自动间隔性保存 由于BGSAVE可以不阻塞服务器执行，所以我们可以设置条件，让服务器每隔一段时间自动保存。举个例子： save 900 1 save 300 10 save 60 10000 这些条件的意思是：900秒内对数据库至少进行了1次修改，300秒内对数据库进行了10次修改…. 服务器程序会根据save选项所设置的保存条件，设置服务器状态redisServer结构的saveparams属性： struct redisServer { // ... // 记录了保存条件的数组 struct saveparam *saveparams; // ... }; saveparams属性是一个数组，数组中的每个元素都是一个saveparam结构，每个saveparam结构都保存了一个save选项设置的保存条件： struct saveparam { // 秒数 time_t seconds; // 修改数 int changes; }; 除了设置保存条件的saveparams数组外，服务器状态还维持着一个dirty计数器，以及一个lastsave属性： dirty计数器记录自上一次SAVE和BGSAVE以后，服务器对数据库状态进行了多少次修改（包括增删改） lastsave则是一个时间戳，记录了上一次执行保存的时间。 当服务器执行修改命令一次以后，dirty计数器就加一。如果是一次性修改多个元素，计数器此时加N redis-\u003eSADD database0 apple orange watermelon Redis的服务器周期性操作函数serverCron默认每隔100毫秒就会执行一次，该函数用于对正在运行的服务器进行维护，它的其中一项工作就是检查save选项所设置的保存条件是否已经满足，如果满足的话，就执行BGSAVE命令。 执行完以后，dirty清0，lastsave更新。 ","date":"2020-12-09","objectID":"/4.%E6%8C%81%E4%B9%85%E5%8C%96/:1:2","tags":["Redis","阅读"],"title":"《Redis设计与实现》（四）持久化","uri":"/4.%E6%8C%81%E4%B9%85%E5%8C%96/"},{"categories":["redis"],"content":"1.3 RDB文件结构 完整的RDB文件如下， RDB是一个二进制文件而不是文本文件。 广义来说，所有文件都是二进制文件。狭义来说，文本文件是基于字符编码的文件，常见的编码有ASCII编码，UNICODE编码等等；二进制文件是基于值编码的文件，也可以理解为自定义编码。 开头的REDIS占5个字节，这5个字符用于检查是不是RDB文件。 db_version长度为4字节，值被解析为RDB版本，比如\"0006\"就代表第6版。 database部分包含着多个数据库的键值对数据，根据大小不同，长度有所不同。 EOF占1个字节，结束位标志。 check_sum是占8字节，保存校验和。服务器在载入时会根据读入的实际数据计算出一个数来和校验值比较，以此来检查是否有损坏。 1.3.1 database部分 每个非空数据库在RDB文件中都可以保存为SELECTDB、db_number、key_value_pairs三个部分，如图所示。 SELECTDB，1字节，当读取到此值时，程序知道接下来要读入一个数据库号码。 db_number，1、2、5字节，保存数据库号码。 key_value_pairs，保存键值对，包括过期时间。 ","date":"2020-12-09","objectID":"/4.%E6%8C%81%E4%B9%85%E5%8C%96/:1:3","tags":["Redis","阅读"],"title":"《Redis设计与实现》（四）持久化","uri":"/4.%E6%8C%81%E4%B9%85%E5%8C%96/"},{"categories":["redis"],"content":"1.3.2 key_value_pairs部分 不带过期时间的键值对在RDB文件中由TYPE、key、value三部分组成， 带有过期时间的键值对在RDB中的结构如下 EPIRETIME_MS，1字节，告诉程序接下来读取一个以毫秒为单位的过期时间。 ms，8字节带符号整数，记录一个以毫秒为单位的UNIX时间戳。 ","date":"2020-12-09","objectID":"/4.%E6%8C%81%E4%B9%85%E5%8C%96/:1:4","tags":["Redis","阅读"],"title":"《Redis设计与实现》（四）持久化","uri":"/4.%E6%8C%81%E4%B9%85%E5%8C%96/"},{"categories":["redis"],"content":"1.3.3 value部分 （1）字符串对象 如果TYPE的值为REDIS_RDB_TYPE_STRING，那么value保存的就是一个字符串对象，字符串对象的编码可以是REDIS_ENCODING_INT或者REDIS_ENCODING_RAW。 如果是INT，则表示对象是一个长度不超过32位的整数，保存方式如下： 其中，ENCODING的值可以是REDIS_RDB_ENC_INT8、REDIS_RDB_ENC_INT16或者REDIS_RDB_ENC_INT32三个常量的其中一个，它们分别代表RDB文件使用8位、16位或者32位来保存整数值integer。 如果是RAW格式，则说明对象是一个字符串值，有压缩和不压缩两种方法来保存。对于没有压缩的字符串，保存格式如下： 压缩后的字符串，保存格式如下： REDIS_RDB_ENC_LZF，表明已被LZF算法压缩 compressed_len，被压缩后的字符串长度 origin_len，原来的长度 compressed_string，被压缩后的字符串 （2）列表对象 如果TYPE的值为REDIS_RDB_TYPE_LIST，那么value保存的就是一个REDIS_ENCODING_LINKEDLIST编码的列表对象，RDB文件保存这种对象的结构如图所示。 每一个列表项都是一个字符串对象，所以程序会以字符串对象的方式来保存。 结构中，3表示列表长度，5表示第一个列表项长度为5，内容为\"hello\"。 （3）集合对象 如果TYPE的值为REDIS_RDB_TYPE_SET，那么value保存的就是一个REDIS_ENCODING_HT编码的集合对象，RDB文件保存这种对象的结构如图所示。 图中elem代表集合的元素，每个集合元素都是一个字符串对象。 和列表一样，4代表集合大小，5代表元素长度，值为\"apple\"。 （4）哈希表对象 如果TYPE的值为REDIS_RDB_TYPE_HASH，那么value保存的就是一个REDIS_ENCODING_HT编码的集合对象，RDB文件保存这种对象的结构如图所示。 例子如下， 哈希表长度为2，第一个键值对，键长度为1的字符串\"a\"，值为5的字符串\"apple\"。 （5）有序集合对象 如果TYPE的值为REDIS_RDB_TYPE_ZSET，那么value保存的就是一个REDIS_ENCODING_SKIPLIST编码的有序集合对象，RDB文件保存这种对象的结构如图所示。 比如： 大小为2，第一个元素是长度为2的字符串\"pi\"，分值被转换为长度为4的字符串\"3.14\"。 （6）INTSET编码的集合 如果TYPE的值为REDIS_RDB_TYPE_SET_INTSET，那么value保存的就是一个整数集合对象，RDB文件保存这种对象的方法是，先将整数集合转换为字符串对象，然后将这个字符串对象保存到RDB文件里面。 （7）ZIPLIST编码的列表、哈希表和有序集合 如果TYPE的值为REDIS_RDB_TYPE_LIST_ZIPLIST、REDIS_RDB_TYPE_HASH_ZIPLIST或者REDIS_RDB_TYPE_ZSET_ZIPLIST，那么value保存的就是一个压缩列表对象，保存策略和上面一一样：先转化为字符串对象。 ","date":"2020-12-09","objectID":"/4.%E6%8C%81%E4%B9%85%E5%8C%96/:1:5","tags":["Redis","阅读"],"title":"《Redis设计与实现》（四）持久化","uri":"/4.%E6%8C%81%E4%B9%85%E5%8C%96/"},{"categories":["redis"],"content":"二、AOF持久化 RDB持久化记录的是数据库本身，而AOF(Append Only File)则记录Redis服务器所执行的写命令。 假如使用如下命令: redis\u003e SET msg \"hello\" OK 则AOF记录形式如下： *2\\r\\n$6\\r\\nSELECT\\r\\n$1\\r\\n0\\r\\n *3\\r\\n$3\\r\\nSET\\r\\n$3\\r\\nmsg\\r\\n$5\\r\\nhello\\r\\n ","date":"2020-12-09","objectID":"/4.%E6%8C%81%E4%B9%85%E5%8C%96/:2:0","tags":["Redis","阅读"],"title":"《Redis设计与实现》（四）持久化","uri":"/4.%E6%8C%81%E4%B9%85%E5%8C%96/"},{"categories":["redis"],"content":"2.1 AOF实现原理 AOF如其名所示，Append Only File，AOF持久化功能的实现可以分为命令追加（appen）、文件写入与同步（sync） 2.1.1 命令追加 如果AOF被打开，则服务器执行完一个命令后，会以协议格式将命令追加到服务器状态aof_buf缓冲区的结尾： struct redisServer { // ... sds aof_buf; // AOF缓冲区 // ... }; 比如执行了SET KEY VALUE后，会将以下协议内容加载到aof_buf缓冲区： *3\\r\\n$3\\r\\nSET\\r\\n$3\\r\\nKEY\\r\\n$5\\r\\nVALUE\\r\\n 2.1.2 AOF文件的写入和同步 Redis的服务器进程就是一个事件循环（loop），这个循环中的文件事件负责接收客户端的命令请求，以及向客户端发送命令回复，而时间事件则负责执行像serverCron函数这样需要定时运行的函数。 服务器每次结束一个事件循环之前，它都会调用flushAppendOnlyFile函数，考虑是否需要将aof_buf缓冲区中的内容写入和保存到AOF文件里面。 这个函数的行为有服务器配置的appendfsync选项来设置，默认为everysec： 默认情况下，距离上次同步过了一秒钟，则服务器会将aof_buf内容写入AOF文件中。 ","date":"2020-12-09","objectID":"/4.%E6%8C%81%E4%B9%85%E5%8C%96/:2:1","tags":["Redis","阅读"],"title":"《Redis设计与实现》（四）持久化","uri":"/4.%E6%8C%81%E4%B9%85%E5%8C%96/"},{"categories":["redis"],"content":"2.2 AOF文件的载入与数据还原 因为AOF文件里面包含了重建数据库状态所需的所有写命令，所以服务器只要读入并且重新执行一遍AOF文件里面保存的写命令，就可以还原服务器关闭之前的数据库状态。 AOF还原数据库的操作步骤如下： 创建一个不带网络连接的伪客户端：因为redis的命令只能在客户端上下文中切换 从AOF中读出一条命令 使用伪客户端执行被读出的命令 重复23步 ","date":"2020-12-09","objectID":"/4.%E6%8C%81%E4%B9%85%E5%8C%96/:2:2","tags":["Redis","阅读"],"title":"《Redis设计与实现》（四）持久化","uri":"/4.%E6%8C%81%E4%B9%85%E5%8C%96/"},{"categories":["redis"],"content":"2.3 AOF重写 随着时间的增长，AOF文件的大小将会越来越大。为了解决这个问题，Redis提供了AOF重写功能。 重写后，Redis服务器可以创建一个新的AOF文件来替代现有的AOF文件，新旧两个AOF文件保存的数据库状态完全相同。 如果要保存一个键值对，我们其实只关心它当前的状态。所以重写策略是：首先从数据库中读取键现在的值，然后用一条命令去记录键值对，用到了aof_rewrite函数。 比如，对list进行RPUSH操作填入\"A\"、“B”、“C”，然后再LPOP一次，我们操作了4次，但其实用RPUSH list A B这一条指令就可以代替。 aof_rewrite函数包含了大量写入操作，调用时会导致线程被长时间阻塞，所以Redis将AOF重写放入子进程里。 还有一个问题：子进程AOF重写时，主进程也在写命令，导致两者状态不一致。因此，Redis服务器设置了一个AOF重写缓冲区，这个缓冲区在服务器创建子进程之后开始使用，当Redis服务器执行完一个写命令之后，它会同时将这个写命令发送给AOF缓冲区和AOF重写缓冲区。 换句话说，子进程执行AOF期间，服务器进程需要： 执行客户端指令 将执行后的命令追加到AOF缓冲区 将执行后的命令追加到AOF重写缓冲区 子进程执行完AOF后，向父进程发送一个信号。父进程接收后： 将AOF重写缓冲区的内容写入AOF文件中，保证一致性。 对新AOF文件改名，原子的(atomic)覆盖现有AOF文件。 在整个AOF后台重写过程中，只有信号处理函数执行时会对服务器进程（父进程）造成阻塞，在其他时候，AOF后台重写都不会阻塞父进程，这将AOF重写对服务器性能造成的影响降到了最低。 ","date":"2020-12-09","objectID":"/4.%E6%8C%81%E4%B9%85%E5%8C%96/:2:3","tags":["Redis","阅读"],"title":"《Redis设计与实现》（四）持久化","uri":"/4.%E6%8C%81%E4%B9%85%E5%8C%96/"},{"categories":["redis"],"content":"数据库 ","date":"2020-12-07","objectID":"/3.%E6%95%B0%E6%8D%AE%E5%BA%93/:0:0","tags":["Redis","阅读"],"title":"《Redis设计与实现》（三）数据库","uri":"/3.%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["redis"],"content":"一、服务器中的数据库 \u0026 数据库的切换 Redis服务器将所有数据结构都保存在服务器状态redis.h/redisServer结构的db数组中，db数组的每一项都是一个redis.h/redisDb结构，每个redisDb结构都代表一个数据库： struct redisServer{ //当前数据库指针 redisDb * db; //数据库数量 int dbnum; }; 初始化时，程序会根据当前服务器的dbnum属性来决定建立数据库的个数，默认创建16个。 每个Redis客户端都有自己的目标数据库，当客户端执行读写命令时，就需要切换数据库。 默认情况下，Redis客户端的目标数据库为0号数据库，但客户端可以通过执行SELECT命令来切换目标数据库。 redis\u003e SET msg \"hello world\" OK redis\u003e GET msg \"hello world\" redis\u003e SELECT 2 OK redis[2]\u003e GET msg (nil) 在服务器内部，客户端状态redisClient结构的Db属性记录了客户端当前的目标数据库，这个属性是一个指向redisDb结构的指针： typedef struct redisClient{ //记录客户端目前正在使用的数据库 redisDb * db; }redisClient; 如果某个客户端的目标数据库为1号数据库，那么这个客户端所对应的客户端状态和服务器状态之间的关系如图： 通过修改指针，使他指向服务器中不同的数据库，从而达到切换的目的。 ","date":"2020-12-07","objectID":"/3.%E6%95%B0%E6%8D%AE%E5%BA%93/:1:0","tags":["Redis","阅读"],"title":"《Redis设计与实现》（三）数据库","uri":"/3.%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["redis"],"content":"二、数据库键空间 ","date":"2020-12-07","objectID":"/3.%E6%95%B0%E6%8D%AE%E5%BA%93/:2:0","tags":["Redis","阅读"],"title":"《Redis设计与实现》（三）数据库","uri":"/3.%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["redis"],"content":"2.1 键空间结构 Redis是一个键值对数据库服务器，每个数据库都是一个redis.h/redisDb结构。其中dict字典保存了数据库中所有的键值对，我们将这个字典称为键空间(key space)。 typedef struct redisDb{ //数据库键空间 dict * dict; }redisDb; 键空间的键就是数据库的键，每个键是一个字符串对象。键空间的值就是数据库的值，可以是字符串对象、列表对象、哈希表对象、集合对象和有序集合对象中的一种。 当我们输入以下命令时： redis\u003e SET message \"hello world\" OK redis\u003e RPUSH alphabet \"a\" \"b\" \"c\" (integer)3 redis\u003e HSET book name \"Redis in Action\" (integer) 1 redis\u003e HSET book author \"Josiah L. Carlson\" (integer) 1 redis\u003e HSET book publisher \"Manning\" (integer) 1 ","date":"2020-12-07","objectID":"/3.%E6%95%B0%E6%8D%AE%E5%BA%93/:2:1","tags":["Redis","阅读"],"title":"《Redis设计与实现》（三）数据库","uri":"/3.%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["redis"],"content":"2.2 键空间的增删改查 2.2.1 添加和修改键 添加新键值对和修改键值的操作是一样的，区别在于键是新的还是旧的。 对象 命令 字符串对象 SET date 2020/1/1 MSET date1 19 date2 20 哈希对象 HSET book name C++primer HMSET fruit name apple size large 列表对象 LSET cloth 0 shirt LPUSH food potato RPUSH brand apple LRANGE level 0 5 集合对象 SADD occupation firefighter 有序集合 ZADD grade 87 tom 65 terry ","date":"2020-12-07","objectID":"/3.%E6%95%B0%E6%8D%AE%E5%BA%93/:2:2","tags":["Redis","阅读"],"title":"《Redis设计与实现》（三）数据库","uri":"/3.%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["redis"],"content":"2.2.2 删除键 对象 命令 字符串对象 DEL date 哈希对象 HDEL myhash field1 myhash field2 列表对象 BLPOP list1 100 BRPOP list1 150 LPOP list2 LREM list3 -2 “hello” 集合对象 SPOP food “rice” SREM food “noodle” 有序集合 ZREM website google.com ZREMRANGEBYLEX drink [sprit (coco ZREMRANGEBYRANK salary 0 2 ZREMRANGEBYSCORE salary 1500 3500 POP在删除的同时，会返回结果，打印到控制台，而REM则是单纯的删除。BLPOP在移除元素时，如果列表没有元素则会等待至超时或发现元素为止。 有序集合范围删除中，LEX表示键，[(表示区间开闭。而ZREMRANGEBYRANK salary 0 2表示删除salary最高的三个。 ","date":"2020-12-07","objectID":"/3.%E6%95%B0%E6%8D%AE%E5%BA%93/:2:3","tags":["Redis","阅读"],"title":"《Redis设计与实现》（三）数据库","uri":"/3.%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["redis"],"content":"2.2.3 查询键 对象 命令 字符串对象 GET time MGET time1 time2 哈希对象 HGET site baidu HMGET site baidu google HGETALL site HKEYS site 列表对象 LINDEX mylist 2 LRANGE mylist 0 2 集合对象 SISMEMBER myset1 “hello” 有序集合 … HGET是根据键返回值，HGETALL则返回所有键值对，HKEYS返回所有键。列表对象根据主要根据下标返回结果。 ","date":"2020-12-07","objectID":"/3.%E6%95%B0%E6%8D%AE%E5%BA%93/:2:4","tags":["Redis","阅读"],"title":"《Redis设计与实现》（三）数据库","uri":"/3.%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["redis"],"content":"三、过期键 ","date":"2020-12-07","objectID":"/3.%E6%95%B0%E6%8D%AE%E5%BA%93/:3:0","tags":["Redis","阅读"],"title":"《Redis设计与实现》（三）数据库","uri":"/3.%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["redis"],"content":"3.1 设置过期时间 通过EXPIRE命令或者PEXPIRE命令，客户端可以以秒或者毫秒精度某个键设置生存时间（Time To Live，TTL），在经过指定的秒数或者毫秒数之后，服务器就会自动删除生存时间为0的键： redis\u003e SET key value OK redis\u003e EXPIRE key 5 (integer) 1 redis\u003e GET key // 5秒之内 \"value\" redis\u003e GET key // 5秒之后 (nil) 与前面相似，客户端可以通过EXPIREAT命令或PEXPIREAT命令，以秒或者毫秒精度给数据库中的某个键设置过期时间（expire time）。过期时间由UNIX时间戳表示。 而TTL命令和PTTL命令则返回一个键的剩余生存时间。 所有的命令在Redis中最终都会转化为PEXPIREAT执行。 在RedisDb结构中，在键空间之外，有一个expires字典专门保存所有键的过期时间，我们称之为过期字典。过期字典保存的值是long long 类型整数，保存一个毫秒精度的UNIX时间戳。 typedef struct redisDb { // ... // 过期字典，保存着键的过期时间 dict *expires; // ... } redisDb; 虽然键空间和过期时间都有相同的键，但他们以指针形式指向同一个键，不会造成空间浪费。 ","date":"2020-12-07","objectID":"/3.%E6%95%B0%E6%8D%AE%E5%BA%93/:3:1","tags":["Redis","阅读"],"title":"《Redis设计与实现》（三）数据库","uri":"/3.%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["redis"],"content":"3.2 移除过期时间 \u0026 计算并返回剩余TTL 移除过期时间 redis \u003e EXPIRE key 123123123 1 redis \u003e TTL key 123123117 redis \u003e PERSIST key 1 redis \u003e TTL key -1 计算并返回剩余TTL reids\u003e EXPIRE key 123123123 1 redis\u003e TTL key 123123118 redis \u003e PTTL key 123123113900 ","date":"2020-12-07","objectID":"/3.%E6%95%B0%E6%8D%AE%E5%BA%93/:3:2","tags":["Redis","阅读"],"title":"《Redis设计与实现》（三）数据库","uri":"/3.%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["redis"],"content":"3.3 过期键的删除策略 通过过期字典知道了哪些键已经过期，那么 过期的键什么时候会被删除呢？ 删除策略有三种： 定时删除：在设置键的过期时间的同时，创建一个定时器（timer），定时结束后删除。 惰性删除：放着不管，每次从键空间获取时检查是否过期，过期就删除。 定期删除：每隔一段时间，程序检查一次数据库，删除过期键。 （1）定时删除 定时删除有利于内存管理，但对CPU不友好。如果过期键太多，删除会占用相当一部分CPU。 所以策略应该是：当有大量命令请求服务器处理时，并且服务器内存充足，就应该优先将CPU资源安排在处理客户端请求上，而不是删除过期键。 创建一个定时器需要用到Redis服务器中的时间事件，而当前时间事件的实现方式——无序链表，查找一个事件的时间复杂度为$O(N)$，并不能高效地处理大量时间事件。 （2）惰性删除 对CPU最友好，但浪费内存。如果数据库中有很多过期键，而这些过期键永远也不会被访问的话，他们就会永远占据空间，可视为内存泄漏。 一些和时间有关的数据，比如日志，在某个时间点后，他们的访问就会很少。如果这类过期数据大量积压，会造成严重的内存浪费。 （3）定期删除 定期删除是一种折中，通过选择较为空闲的时间点来处理过期键，减少CPU压力。同时也能及时释放内存，避免内存泄漏。 在Redis中，实际使用的是惰性删除和定期删除这两种。 （1）Redis中的惰性删除 存在于db.c/expireIfNeeded函数。所有读写数据库的Redis命令在执行之前都会调用expireIfNeeded函数对输入键进行检查： 过期，函数将输入键删除 不过期，函数不动作 （2）Redis中的定期删除 过期键的定期删除策略由redis.c/activeExpireCycle函数实现，每当Redis的服务器周期性操作redis.c/serverCron函数执行时，activeExpireCycle函数就会被调用，它在规定的时间内，分多次遍历服务器中的各个数据库，从数据库的expires字典中随机检查一部分键的过期时间，并删除其中的过期键。 全局变量current_db会记录当前activeExpireCycle函数检查的进度，并在下一次检查时接着上一次的进度进行处理。比如说，如果当前activeExpireCycle函数在遍历10号数据库时返回了，那么下次就会从11号数据库开始工作。 如果所有数据库都被检查了一遍，则current_db将会被置0，然后开始新一轮检查。 ","date":"2020-12-07","objectID":"/3.%E6%95%B0%E6%8D%AE%E5%BA%93/:3:3","tags":["Redis","阅读"],"title":"《Redis设计与实现》（三）数据库","uri":"/3.%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["redis"],"content":"四、数据库通知 通知是Redis2.8新增的功能，可以让客户端通过订阅给定的频道或者模式，来获知数据库中键的变化，以及数据库中命令的执行情况。 ","date":"2020-12-07","objectID":"/3.%E6%95%B0%E6%8D%AE%E5%BA%93/:4:0","tags":["Redis","阅读"],"title":"《Redis设计与实现》（三）数据库","uri":"/3.%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["redis"],"content":"4.1 订阅通知 订阅有两种模式： 订阅某一个键，返回键的所有操作 订阅某一个操作，返回执行这个操作的键 情况1，从0号数据库订阅了键message的消息。如果此时有其他客户端操作了message，则会将消息通知到此处。 127.0.0.1:6379\u003e SUBSCRIBE _ _keyspace@0_ _:message Reading messages... (press Ctrl-C to quit) 1) \"subscribe\" // 订阅信息 2) \"__keyspace@0__:message\" 3) (integer) 1 1) \"message\" //执行SET命令 2) \"_ _keyspace@0_ _:message\" 3) \"set\" 1) \"message\" //执行EXPIRE命令 2) \"_ _keyspace@0_ _:message\" 3) \"expire\" 情况2，客户端订阅了0号数据库中的DEL命令。 127.0.0.1:6379\u003e SUBSCRIBE _ _keyevent@0_ _:del Reading messages... (press Ctrl-C to quit) 1) \"subscribe\" // 订阅信息 2) \"_ _keyevent@0_ _:del\" 3) (integer) 1 1) \"message\" //键key执行了DEL命令 2) \"_ _keyevent@0_ _:del\" 3) \"key\" 1) \"message\" //键number执行了DEL命令 2) \"_ _keyevent@0_ _:del\" 3) \"number\" ","date":"2020-12-07","objectID":"/3.%E6%95%B0%E6%8D%AE%E5%BA%93/:4:1","tags":["Redis","阅读"],"title":"《Redis设计与实现》（三）数据库","uri":"/3.%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["redis"],"content":"4.2 发送通知 发送数据库通知的功能是由notify.c/notifyKeyspaceEvent函数实现，函数声明如下： void notifyKeyspaceEvent(int type,char *event,robj *key,int dbid); type参数是发送的通知的类型，event、keys和dbid分别是事件的名称、产生事件的键，以及产生事件的数据库编号，函数会根据type参数以及这三个参数来构建事件通知的内容，以及接收通知的频道名。 比如SADD命令的实现函数中，通知的发送方式是 void saddCommand(redisClient* c) { //... if(added) { //...添加成功，发送通知 notifyKeyspaceEvent(REDIS_NOTIFY_SET,\"add\",c-\u003eargv[1],c-\u003edb-\u003eid); //... } } 当SADD命令成功地向集合添加了一个集合元素之后，命令就会发送通知，该通知的类型为REDIS_NOTIFY_SET（表示这是一个集合键通知），名称为sadd（表示这是执行SADD命令所产生的通知）。 发布时调用的notifyKeyspaceEvent函数逻辑是： 检查服务器是否允许发送此类通知，如果不允许就返回 是否允许发送键空间通知（4.1提到的情况1），允许就发送 是否允许发送键事件通知（4.2提到的情况2），允许就发送 ","date":"2020-12-07","objectID":"/3.%E6%95%B0%E6%8D%AE%E5%BA%93/:4:2","tags":["Redis","阅读"],"title":"《Redis设计与实现》（三）数据库","uri":"/3.%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["redis"],"content":"Redis中的数据结构 ","date":"2020-12-04","objectID":"/1.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:0:0","tags":["Redis","阅读"],"title":"《Redis设计与实现》（一）数据结构","uri":"/1.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["redis"],"content":"一、简单动态字符串 ","date":"2020-12-04","objectID":"/1.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:1:0","tags":["Redis","阅读"],"title":"《Redis设计与实现》（一）数据结构","uri":"/1.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["redis"],"content":"引言 Redis中没有直接使用C语言传统的字符串表示（以空字符结尾的字符数组），而是自己构建了一种简单动态字符串（SDS）的抽象类型，并将SDS用作Redis的默认字符串表示。 在Redis中，C字符串只会用在一些无须修改的地方，比如打印常量： redislog(REDIS_WARNING,\"Redis is now ready to exit, bye bye...\"); 如果是在需要修改的地方，则会使用SDS来表示： redis\u003e RPUSH fruits \"apple\" \"banana\" \"cherry\" (integer) 3 Redis将在数据库中创建一个新的键值对，其中： key是一个字符串对象，底层包含了一个字符串fruits的SDS。 value是一个列表对象，底层包含了三个字符串对象，由SDS实现。 ","date":"2020-12-04","objectID":"/1.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:1:1","tags":["Redis","阅读"],"title":"《Redis设计与实现》（一）数据结构","uri":"/1.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["redis"],"content":"1.1 SDS的定义 SDS是一个结构体，定义在sds.h/sdshdr中： struct{ //记录buf数组中已经使用的字节的数量 //等于SDS所保存字符串的长度 int len; //记录buf数组中未使用字节的数量 int free; //字节数组，用于保存字符串 char buf[]; } 下面给出了一个示例：free=0表示所有空间都被使用，未使用空间为0。len=5表示SDS字符串长度为5。buf就是字符串实体。 保存空字符的1字节空间不计算在len之内。遵循空字符结尾这一原则，SDS可以直接重用一部分C字符串函数库里的函数。 比如： printf(\"%s\",s-\u003ebuf) ","date":"2020-12-04","objectID":"/1.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:1:2","tags":["Redis","阅读"],"title":"《Redis设计与实现》（一）数据结构","uri":"/1.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["redis"],"content":"1.2 SDS与C字符串的区别 C语言使用的简单的字符串表示方式， 并不能满足 Redis 对字符串在安全性、效率、以及功能方面的要求。主要有以下几个弊端。 获取字符串长度的效率： C字符串需要遍历字符串才能得到长度，时间复杂度为O(n)。SDS底层维护了一个len，所以获取字符串长度的时间复杂度为O(1)。 杜绝缓冲区溢出： 由于C字符串不记录长度，当我们拼接两个字符串的时候，容器可能因为空间不足发生溢出。redis中的sdscat将在执行拼接操作前检查长度是否充足，若不足则先拓展空间，再拼接。 减少修改字符串长度时所需的内存分配次数： C字符串类似于数组，每次修改大小都会重新分配内存。Redis的分配原理类似于std::vector，通过空间预分配的办法优化字符串增加，分配规则如下： len小于1MB，则free和len一样大。例如修改后len为13字节，free也为13字节，buf的实际长度就位13 + 13 + 1 = 27字节 len大于1MB，则free为1MB。例如修改后len为30MB，free为1MB，buf的实际长度为1MB + 30MB + 1byte 二进制安全： C字符串使用\\0结尾，使得C字符串只能保存文本数据，不能保存像图片、音频、视频、压缩文件这样的二进制数据。 SDS使用len来判断是否结束，而不是\\0。 兼容部分C语言函数： 因为SDS也遵循使用\\0结尾的规则，所以SDS也可以使用\u003cstring.h\u003e中的部分函数。 ","date":"2020-12-04","objectID":"/1.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:1:3","tags":["Redis","阅读"],"title":"《Redis设计与实现》（一）数据结构","uri":"/1.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["redis"],"content":"二、链表 ","date":"2020-12-04","objectID":"/1.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:2:0","tags":["Redis","阅读"],"title":"《Redis设计与实现》（一）数据结构","uri":"/1.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["redis"],"content":"引言 链表随机读写能力较差O(n)，但增删和重排能力较强。C语言没有链表结构，Redis自制了一个链表。 ","date":"2020-12-04","objectID":"/1.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:2:1","tags":["Redis","阅读"],"title":"《Redis设计与实现》（一）数据结构","uri":"/1.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["redis"],"content":"2.1 链表和链表节点的实现 每个链表节点使用一个adlist.h/listNode结构来表示 typedef struct listNode{ //前置节点 struct listNode * prev; //后驱节点 struct listNode * next; //节点的值 void *value; }listNode; 多个Node组成一个双端链表 但是为了方便，Redis设计了adlist.h/list来持有链表。 typedef struct list { //表头节点 listNode * head; //表尾节点 listNode * tail; //链表所包含的节点数量 unsigned long len; //节点值复制函数 void *(*dup)(void * ptr) //节点值释放函数 void (*free)(void * ptr) //节点值对比函数 int (*match)(void * ptr,void * key) } Redis的链表实现的特性可以总结如下： 双端 无环，表头和结尾都指向null 带有表头表尾指针，访问首尾都是O(1) 多态，链表节点使用void * 指针来保存节点值 ","date":"2020-12-04","objectID":"/1.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:2:2","tags":["Redis","阅读"],"title":"《Redis设计与实现》（一）数据结构","uri":"/1.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["redis"],"content":"三、字典 ","date":"2020-12-04","objectID":"/1.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:3:0","tags":["Redis","阅读"],"title":"《Redis设计与实现》（一）数据结构","uri":"/1.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["redis"],"content":"引言 在字典中， 一个键（key）可以和一个值（value）进行关联（或者说将键映射为值）， 这些关联的键和值就被称为键值对。字典中的每个键必须保证都是独一无二的。C并没有这样的结构，所以Redis自己实现了。 ","date":"2020-12-04","objectID":"/1.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:3:1","tags":["Redis","阅读"],"title":"《Redis设计与实现》（一）数据结构","uri":"/1.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["redis"],"content":"3.1 字典的实现 Redis的字典使用哈希表作为底层实现，一个哈希表里面可以有多哥哈希表节点，而每个哈希表节点就保存了字典中的一个键值对。 3.1.1 哈希表 Redis字典使用的哈希表由dict.h/dictht结构定义： typedef struct dictht{ //哈希表数组指针 dictEntry **table; //哈希表大小 unsigned long size; //哈希表大小掩码，用于计算索引值，总是等于size - 1 unsigned long sizemask; //该哈希表已有节点的数量 unsigned long used; } table是一个数组，数组中的每个元素都是指向dict.h/dictEntry的指针 3.1.2 哈希表节点 哈希表节点使用dictEntry结构表示，每个dictEntry结构都保存一个键值对： typedef struct dictEntry { // 键 void *key; // 值 union { void *val; uint64_t u64; int64_t s64; } v; // 指向下个哈希表节点，形成链表 struct dictEntry *next; } dictEntry; v 属性则保存着键值对中的值， 值可以是一个指针， 或者是一个 uint64_t 整数， 又或者是一个 int64_t 整数。 next 属性是指向另一个哈希表节点的指针， 这个指针可以将多个哈希值相同的键值对连接在一次， 以此来解决键冲突（collision）的问题 下图中，键的索引值都是2，通过链表的形式完成了冲突的规避。 3.1.3 字典 Redis中的字典由dict.h/dict结构表示 typedef struct dict { // 类型特定函数 dictType *type; // 私有数据 void *privdata; // 哈希表 dictht ht[2]; // rehash 索引 // 当 rehash 不在进行时，值为 -1 int rehashidx; /* rehashing not in progress if rehashidx == -1 */ } dict; 其中type属性和privdata属性是针对不同类型的键值对，为创建多态字典而设置的。 type属性是一个指向dictType结构的指针，每个dictType结构保存了一簇用于操作特定类型键值对的函数。 privdata属性则保存了需要传给那些类型特定函数的可选参数 typedef struct dictType { // 计算哈希值的函数 unsigned int (*hashFunction)(const void *key); // 复制键的函数 void *(*keyDup)(void *privdata, const void *key); // 复制值的函数 void *(*valDup)(void *privdata, const void *obj); // 对比键的函数 int (*keyCompare)(void *privdata, const void *key1, const void *key2); // 销毁键的函数 void (*keyDestructor)(void *privdata, void *key); // 销毁值的函数 void (*valDestructor)(void *privdata, void *obj); } dictType; 哈希表数组ht包含了两个元素，一般情况下，字典只使用ht[0]哈希表，ht[1]哈希表只会在对ht[0]哈希表进行rehash时使用。 除了ht[1]之外，另一个和rehash有关的属性是rehashidx：它记录了rehash目前的进度，如果目前没有在进行rehash，那么它的值为-1。 下图为一个普通状态下（没有rehash）的字典 ","date":"2020-12-04","objectID":"/1.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:3:2","tags":["Redis","阅读"],"title":"《Redis设计与实现》（一）数据结构","uri":"/1.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["redis"],"content":"3.2 哈希算法 程序需要先根据键值对的键计算出哈希值和索引值，然后再根据索引值，将包含新键值对的哈希表节点放到哈希表数组的指定索引上面。 Redis计算哈希值和索引值的方法如下： //使用字典设置的哈希函数，计算出键key的哈希值 hash = dict-\u003etype-\u003ehashFunction(key) //使用哈希表的sizemask属性和哈希值，计算出索引值 //根据情况不同，ht[x]可能是ht[0]或者ht[1] index = hash \u0026 dict-\u003eht[x].sizemask 举个例子，加入想要将键值对\u003ck0,v0\u003e添加到下面的字典中。 假设计算出的哈希值为8，则index的计算方式为： index = hash \u0026 dict-\u003eht[0].sizemask-1 = 8 \u0026 3 = 0 至于Redis的哈希值计算方法，使用的是MurmurHash2。这种算法的优点在于，即使输入的键是有规律的，算法仍能给出一个很好的随机分布性，并且算法的计算速度也非常快。 ","date":"2020-12-04","objectID":"/1.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:3:3","tags":["Redis","阅读"],"title":"《Redis设计与实现》（一）数据结构","uri":"/1.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["redis"],"content":"3.3 Rehash 随着操作的不断执行，哈希表保存的键值对会逐渐地增多或减少，为了让哈希表的负载因子（load Factor） 维持在一个合理的范围之内，当哈希表保存的键值对数量太多或太少时，程序需要对哈希表的大小进行相应的扩展或者收缩。 Rehash的关键在于重新分配哈希表的大小，分配的原则如下： 如果执行拓展操作，ht[1]的大小为第一个大于等于ht[0].used * 2的$2^n$。 如果执行收缩操作，ht[1]的大小为第一个大于等于ht[0].used的$2^n$ 完成分配后，将保存在ht[0]中的所有键值对rehash到ht[1]上面，然后将ht[1]设置为ht[0]，并在ht[1]新创建一个空白哈希表，为下一次rehash做准备。 决定是和否Rehash的要素来自于负载因子，计算方法如下： //负载因子 = 哈希表已保存节点数量 / 哈希表大小 load_factor = ht[0].used / ht[0].size ","date":"2020-12-04","objectID":"/1.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:3:4","tags":["Redis","阅读"],"title":"《Redis设计与实现》（一）数据结构","uri":"/1.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["redis"],"content":"3.4 渐进式Rehash 3.4.1 渐进式rehash的操作 如果键值对很多，则将ht[0]重新hash到ht[1]上，则会导致服务器在一段时间内停止服务。为了避免这种问题，需要分多次渐进式的慢慢映射。 关键点在于维持一个索引计数器变量rehashidx，并将它的值设为0，表示rehash工作正式开始。 在rehash进行期间，每次对字典执行增删改查，程序除了执行指定的操作以外，还会顺带将ht[0]哈希表在rehashidx索引上的所有键值对rehash到ht[1]上，当rehash工作全部完成之后，程序将rehashidx属性的值增一。 全部操作完成后，程序将rehashidx的值设为-1，表示rehash操作已经完成。 渐进式 rehash 的好处在于它采取分而治之的方式， 将 rehash 键值对所需的计算工作均滩到对字典的每个增删改查上， 从而避免了集中式 rehash 而带来的庞大计算量。 3.4.2 渐进式rehash执行期间的哈希表操作 因为在进行渐进式rehash的过程中，字典会同时使用ht[0]和ht[1]两个哈希表，所以在渐进式rehash期间，字典的操作分为两种。 删除、更改、查询： 会在两个哈希表中进行操作。例如要在字典里面查找一个键的话，程序会先在ht[0]里面进行查找，如果没找到的话，就会继续到ht[1]里面进行查找。删除、更改也如此。 增加： 只会在ht[1]里面进行保存，不会再ht[0]中操作，这一措施保证了ht[0]包含的键值对数量只减不增，并随着rehash的操作执行而变成空表。 ","date":"2020-12-04","objectID":"/1.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:3:5","tags":["Redis","阅读"],"title":"《Redis设计与实现》（一）数据结构","uri":"/1.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["redis"],"content":"四、跳跃表 ","date":"2020-12-04","objectID":"/1.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:4:0","tags":["Redis","阅读"],"title":"《Redis设计与实现》（一）数据结构","uri":"/1.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["redis"],"content":"引言 我们知道链表随机读写的能力很差，当增删改查的时候，如果要找到目标元素就需要遍历链表，时间复杂度为O(n)。假设某个数据结构是有序的，我们会想到使用二分查询来快速查找，但是链表是没有索引的，所以我们需要为链表添加索引。 跳表的平均查找和插入时间复杂度都是$O(logN)$。 快速查询是通过维护一个多层次的链表，且每一层的链表中的元素都是前一层链表元素的子集。一开始，算法在最稀疏的层次进行搜索，直至需要查找的元素在该层两个相邻的元素中间。这时，算法将跳转到下一个层次，重复刚才的搜索，直到找到需要查找的元素为止。 ","date":"2020-12-04","objectID":"/1.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:4:1","tags":["Redis","阅读"],"title":"《Redis设计与实现》（一）数据结构","uri":"/1.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["redis"],"content":"4.1 跳跃表的实现 Redis的跳跃表由redis.h/zskiplistNode和redis.h/zskiplist两个结构定义，其中zskiplistNode结构用于表示跳跃表的节点，而zskiplist结构则用于保存跳跃表节点的相关信息，比如节点的数量，以及指向表头表尾节点的指针。 4.1.1 跳跃表节点 zskiplistNode的定义如下： typedef struct zskiplistNode{ //后退指针 struct zskiplistNode * backward; //分值 double score; //成员对象 robj *obj; //层 struct zskiplistLevel{ //前进指针 struct zskiplistNode * forward; //跨度 unsigned int span; }level[]; }zskiplistNode; 层(level)： 每次创建一个新跳跃表节点的时候，程序都根据幂次定律(power law，越大的数出现的概率越小)随机生成一个介于1~32之间的值作为level数组的大小，这个大小就是层的高度。 前进指针： 前进指针分属于不同的层，用于访问位于表尾方向的其他节点。 跨度： 跨度也分属不同的层，指向NULL的所有前进指针的跨度为0，则记录了前进指针所指向节点和当前节点的距离。 跨度实际上是用来计算位次(rank)的：将沿途访问过的所有层的跨度累计起来，得到的结果就是目标节点在跳跃表中的排位。 后退指针： 节点的后退指针(backward属性)用于从表尾向表头方向访问节点，但是只能每次只能后退一个节点。 分值和成员： 节点的分值(score属性)是一个double类型的浮点数，所有节点都使用分值从小到大排序。 节点的成员(obj属性)是一个指针，它指向一个字符串对象，而字符串对象则保存着一个SDS值。 排序规则：在跳跃表中，各个节点保存的对象必须是唯一的，但是多个节点的分值可以相同。首先按照分值从小到大排序，如果分值相同则根据成员对象的字典序排序。 4.1.2 跳跃表 使用一个zskiplist结构来管理zskiplistNode节点，程序可以更方便地对整个跳跃表进行管理。 typedef struct zskiplist{ //表头节点和表尾节点 struct zskiplistNode * tail,* header; //表中节点的数量 unsigned long length; //表中层数最大的节点的层数 int level; }zskiplist; ","date":"2020-12-04","objectID":"/1.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:4:2","tags":["Redis","阅读"],"title":"《Redis设计与实现》（一）数据结构","uri":"/1.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["redis"],"content":"五、整数集合 ","date":"2020-12-04","objectID":"/1.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:5:0","tags":["Redis","阅读"],"title":"《Redis设计与实现》（一）数据结构","uri":"/1.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["redis"],"content":"引言 当一个集合中只包含整数，并且元素的个数不是很多的话，redis会用整数集合作为底层存储，它可以节省很多内存。 ","date":"2020-12-04","objectID":"/1.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:5:1","tags":["Redis","阅读"],"title":"《Redis设计与实现》（一）数据结构","uri":"/1.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["redis"],"content":"5.1 整数集合的实现 整数集合(intset)是Redis用于保存整数值的集合抽象数据结构，它可以保存类型为int16_t、int32_t、int64_t的整数值，并且保证集合中不会出现重复元素。 每个intset.h/intset结构表示一个整数集合： typedef struct intset{ //编码方式 uint32_t encoding; //集合包含的元素数量 uint32_t length; //保存元素的数组 int8_t contents[]; }intset; contents 数组是整数集合的底层实现： 整数集合的每个元素都是contents数组的一个数组项(item)，从小到大有序地排列，不包含任何重复项。 虽然intset结构将contents属性声明为int8_t类型的数组，但实际上contents数组并不保存任何int8_t类型的值——contents数组的真正类型取决于encoding属性的值: encoding 为 INTSET_ENC_INT16，int16_t 类型的数组，范围$[-2^{16},2^{16}-1]$ encoding 为INTSET_ENC_INT32 ， 是一个 int32_t 类型的数组。 encoding 为 INTSET_ENC_INT64 ， 是一个 int64_t 类型的数组 下图是一个实例： ","date":"2020-12-04","objectID":"/1.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:5:2","tags":["Redis","阅读"],"title":"《Redis设计与实现》（一）数据结构","uri":"/1.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["redis"],"content":"5.2 升级 5.2.1 升级的过程 每当我们要将一个新元素添加到整数集合里面，并且新元素的类型比整数集合元素的类型长时，整数集合需要先进行升级(upgrade)，然后才能将新元素添加到整数集合里面。 过程如下： 根据新类型，扩展整数集合底层数组的空间大小，并为新元素分配空间。 将底层数组现有的所有元素都转换成与新元素相同的类型，并将类型转换后的元素有序放置。 将新元素添加到底层数组里面 假设想要在16位编码的intset中插入一个32位的65535数据，原来的集合是这样的 需要扩容位$32 \\times 4 = 12$ 剩下的就要对元素重排。 先将3移动到新intset结构的索引2的位置上，然后将2移动到索引1的位置，然后将1移动到索引0的位置。最后再将65535移动到索引3的位置。 5.2.2 升级的好处 提升灵活性 可以随意地将int16_t、int32_t、int64_t类型添加到集合中，而不必担心出现类型错误。 节约内存 想要保存三种int类型的话，最简单的方法是直接使用int64_t来保存。而整数集合现在的做法既可以让集合能同时保存三种不同类型的值，又可以确保升级操作只会在有需要的时候进行，这可以尽量节省内存。 ","date":"2020-12-04","objectID":"/1.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:5:3","tags":["Redis","阅读"],"title":"《Redis设计与实现》（一）数据结构","uri":"/1.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["redis"],"content":"5.3 降级 整数集合不支持降级操作， 一旦对数组进行了升级， 编码就会一直保持升级后的状态。 即使我们将集合里唯一一个真正需要使用 int64_t 类型来保存的元素 4294967295 删除了， 整数集合的编码仍然会维持 INTSET_ENC_INT64。 ","date":"2020-12-04","objectID":"/1.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:5:4","tags":["Redis","阅读"],"title":"《Redis设计与实现》（一）数据结构","uri":"/1.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["redis"],"content":"六、压缩列表 ","date":"2020-12-04","objectID":"/1.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:6:0","tags":["Redis","阅读"],"title":"《Redis设计与实现》（一）数据结构","uri":"/1.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["redis"],"content":"引言 压缩列表（ziplist）是列表键和哈希键的底层实现之一。当一个列表键只包含少量列表项， 并且每个列表项要么就是小整数值或长度比较短的字符串， 那么 Redis 就会使用压缩列表来做列表键的底层实现。 ","date":"2020-12-04","objectID":"/1.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:6:1","tags":["Redis","阅读"],"title":"《Redis设计与实现》（一）数据结构","uri":"/1.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["redis"],"content":"6.1 压缩列表的构成 压缩列表是Redis为了节约内存而开发的，由一系列特殊编码的连续内存块组成的顺序型(sequential)数据结构。 属性 类型 长度 作用 zlbytes uint32_t 4字节 整个压缩列表占用内存字节数 zltail uint32_t 4字节 记录表尾节点距离表起始地址有多少个字节 zllen uint16_t 2字节 记录节点数量 entryX 不定 节点 zlen uint8_t 1字节 用于标记末端 zlbytes属性的值为0x50(十进制80)，表示压缩列表总长为80字节 zltail属性的值为0x3c(十进制60)，如果一个指向压缩列表起始地址的指针p，那么只要用指针p加上偏移量60，就可以计算出表尾节点entry3的地址。 zllen属性的值为0x3(十进制3)，表示压缩列表包含三个节点。 ","date":"2020-12-04","objectID":"/1.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:6:2","tags":["Redis","阅读"],"title":"《Redis设计与实现》（一）数据结构","uri":"/1.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["redis"],"content":"6.2 压缩列表的节点构成 每个压缩列表节点可以保存一个字节数组或一个整数值，其中，字节数组可以是以下三种长度的其中一种： 长度小于等于63($2^6-1$)字节的字节数组。 长度小于等于16383($2^{14}-1$) 长度小于等于4294967295($2^{32}-1$) 而整数值则可以是一下六项长度的其中一种： 4位长，介于0和12之间的无符号整数 1字节长的有符号整数 3字节长的有符号整数 int16_t类型整数 int32_t类型整数 int64_t类型整数 每个压缩列表节点都由previous_entry_length、encoding、content三个部分构成。 previous_entry_length 以字节为单位，记录了压缩列表中前一个节点的长度。这个属性的长度可以是1字节或5字节，如果前一个小于254则使用1字节，反之使用5字节 （其中属性的第一字节会被设置为0xFE(十进制254)，而之后的四个字节则用于保存前一节点的长度） 因为节点的previous_entry_length属性记录了前一个节点的长度，所以程序可以通过指针运算，根据当前节点的起始地址来计算出前一个节点的起始地址。 例如：现在有一个指向当前节点起始地址的指针c，那么我们只要用指针c减去当前节点previous_entry_length属性的值，就可以得出一个指向前一个节点起始地址的指针p。 p = c - current_entry.previous_entry_length encoding 节点的encoding属性记录了节点的content属性所保存数据的类型以及长度。编码由8位组成。 如果是字符类型，则开头两位00，01，,01分别表示1字节，2字节，5字节，后6位表示字符串长度。 保存每个元素是一个字节的数组，长度11。 如果是整数类型，则开头必定是11，然后从第六位开始往低位开始计数： 每个元素int16_t，值为10086 ","date":"2020-12-04","objectID":"/1.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:6:3","tags":["Redis","阅读"],"title":"《Redis设计与实现》（一）数据结构","uri":"/1.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["redis"],"content":"6.3 连锁更新 每个节点的previous_entry_length属性都记录了前一个节点的长度： 如果前一节点的长度小于254字节，那么previous_entry_length属性需要用1字节长的空间来保存这个长度值 如果前一节点的长度大于等于254字节，那么previous_entry_length属性需要用5字节长的空间来保存这个值。 假设现在有一些长度为252字节的节点，他们在各个节点的previous_entry_length中保存为1字节。现在插入了一个260字节的新节点，new将成为e1的前置节点。 因为e1的previous_entry_length的变化，导致e1的长度也发生了变化$252+4=256\u003e254$，所以导致e2也必须更新他的previous_entry_length。这就是连锁更新。 除了添加节点外，删除节点也会导致连锁更新，若删除一个260字节的节点，则后一个节点长度也会变化。如果很不凑巧，小于254，则又会引起后续效应。 连锁更新在最坏情况下需要对压缩列表执行N次空间重分配操作，而每次空间重分配的最坏复杂度为$O(N)$，所以连锁更新的最坏复杂度为$O(N^2)$。 ","date":"2020-12-04","objectID":"/1.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:6:4","tags":["Redis","阅读"],"title":"《Redis设计与实现》（一）数据结构","uri":"/1.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["redis"],"content":"对象 ","date":"2020-12-04","objectID":"/2.%E5%AF%B9%E8%B1%A1/:0:0","tags":["Redis","阅读"],"title":"《Redis设计与实现》（二）对象","uri":"/2.%E5%AF%B9%E8%B1%A1/"},{"categories":["redis"],"content":"引言 前一章介绍了Redis的主要数据结构，但Redis并没有直接使用这些数据结构来实现键值对数据库， 而是基于这些数据结构创建了一个对象系统 ，这个系统包含字符串对象、列表对象、哈希对象、集合对象和有序集合对象这五种类型的对象。 使用对象有两个好处： 执行命令前，根据对象类型来判断是否可以执行此命令。 针对不同使用场景，为对象设置多种不同的数据结构实现，达到优化的目的。 此外，对象系统还引入了引用计数实现内存回收机制，以及对象共享。 ","date":"2020-12-04","objectID":"/2.%E5%AF%B9%E8%B1%A1/:1:0","tags":["Redis","阅读"],"title":"《Redis设计与实现》（二）对象","uri":"/2.%E5%AF%B9%E8%B1%A1/"},{"categories":["redis"],"content":"一、对象的类型和编码 Redis中的每一个键值对的键和值都是一个对象，每个对象都由一个redisObject结构表示，该结构中和保存数据有关的三个属性分别是type属性、encoding属性和ptr属性。 typedef struct redisObject{ // 类型 unsigned typed : 4; // 编码 unsigned encoding :4; //指向底层实现数据结构的指针 void * ptr; }obj; 结构体的冒号表示位域，表示该变量占用的二进制位数。 ","date":"2020-12-04","objectID":"/2.%E5%AF%B9%E8%B1%A1/:2:0","tags":["Redis","阅读"],"title":"《Redis设计与实现》（二）对象","uri":"/2.%E5%AF%B9%E8%B1%A1/"},{"categories":["redis"],"content":"1.1 对象的类型 对象的type属性记录了对象的类型，属性的值如下表所示： 类型常量 对象的名称 REDIS_STRING 字符串对象 REDIS_LIST 列表对象 REDIS_HASH 哈希对象 REDIS_SET 集合对象 REDIS_ZSET 有序集合对象 对于Redis数据库保存的键值对来说，键总是一个字符串对象，而值可以是上表中的其中一个 所以，当我们称呼一个数据库键位“字符串键”时，我们指的是“这个数据库键所对应的值为字符串对象”；同理，当我们称呼一个键位“列表键” 时，我们指的是“这个 数据库键 所 对应的值为列表对象” ","date":"2020-12-04","objectID":"/2.%E5%AF%B9%E8%B1%A1/:2:1","tags":["Redis","阅读"],"title":"《Redis设计与实现》（二）对象","uri":"/2.%E5%AF%B9%E8%B1%A1/"},{"categories":["redis"],"content":"1.2 对象的编码 对象的ptr指针指向对象的底层实现数据结构，而这些数据结构由对象的encoding属性决定。encoding属性如下表所示： 编码常量 编码所对应的底层数据结构 REDIS_ENCODING_INT long类型的整数 REDIS_ENCODING_EMBSTR embstr编码的简单动态字符串 REDIS_ENCODING_RAW 简单动态字符串 REDIS_ENCODING_HT 字典 REDIS_ENCODING_LINKEDLIST 双端链表 REDIS_ENCODING_ZIPLIST 压缩列表 REDIS_ENCODING_INTSET 整数集合 REDIS_ENCODING_ZSKIPLIST 跳跃表和字典 ","date":"2020-12-04","objectID":"/2.%E5%AF%B9%E8%B1%A1/:2:2","tags":["Redis","阅读"],"title":"《Redis设计与实现》（二）对象","uri":"/2.%E5%AF%B9%E8%B1%A1/"},{"categories":["redis"],"content":"二、字符串对象 ","date":"2020-12-04","objectID":"/2.%E5%AF%B9%E8%B1%A1/:3:0","tags":["Redis","阅读"],"title":"《Redis设计与实现》（二）对象","uri":"/2.%E5%AF%B9%E8%B1%A1/"},{"categories":["redis"],"content":"2.1 编码方式 字符串对象的编码可以是int、raw或者embstr。 如果一个字符串对象保存的是整数值，并且这个整数值可以用long类型来表示，那么字符串对象会将整数值保存在字符串对象结构的ptr属性里面(将void*转换为long)，并将字符串对象的编码设置为int。 如果字符串对象保存的是一个字符串值，并且这个字符串值的长度大于39字节，那么字符串对象将使用一个简单动态字符串(SDS) 来保存这个字符串，并将对象的编码设置为raw 如果字符串对象保存的是一个字符串值，并且这个字符串值的长度小于等于39字节，那么字符串对象将使用embstr编码的方式来保存这个字符串。 embstr编码是一种专门用于保存端字符串的一种优化编码方式。这种编码和raw编码一样，都使用redisObject结构和sdshdr结构来表示字符串对象，区别在于： raw编码会调用两次内存来分配redisObject结构和sdshdr结构。 embstr编码只调用一次内存来分配一块连续的空间。 由于减少了内存分配的次数，以及将零散的内存整合到一起，这种编码的字符串对象比起raw编码能够更好地利用缓存带来的优势。 如果保存浮点数，则会先转化为字符串类型保存。比如保存3.14就会先保存为\"3.14\"。但在有需要的时候，程序会将保存在字符串对象里面的字符串值转换回浮点数值，执行某些操作，然后再将执行操作所得的浮点数值转换回字符串值，并继续保存在字符串对象里面。 下表是值和对应的编码类型 值 编码 可以用long类型保存的整数 int 可以用long double类型保存的浮点数 embstr或者raw 字符串值，长度太大没办法用long类型表示的参数 embstr或者raw ","date":"2020-12-04","objectID":"/2.%E5%AF%B9%E8%B1%A1/:3:1","tags":["Redis","阅读"],"title":"《Redis设计与实现》（二）对象","uri":"/2.%E5%AF%B9%E8%B1%A1/"},{"categories":["redis"],"content":"2.2 编码转换 编码之间也会有互相转换的情况。对于int编码的字符串对象来说，如果因为命令导致这个对象保存的不再是整数值，而是一个字符串值，那么字符串对象的编码将从int变为raw。 redis\u003e SET number 10086 OK redis\u003e OBJECT ENCODING number \"int\" redis\u003e APPEND number \" is a good number!\" (integer) 23 redis\u003e GET number \"10086 is a good number!\" redis\u003e OBJECT ENCODING number \"raw\" 因为Redis没有为embstr编码的字符串对象编写任何相应的修改程序，所以embstr编码的字符串对象实际上是只读的。当修改embstr编码的字符串对象，程序会先将对象的编码从embstr转换成raw，然后再执行修改命令。 ","date":"2020-12-04","objectID":"/2.%E5%AF%B9%E8%B1%A1/:3:2","tags":["Redis","阅读"],"title":"《Redis设计与实现》（二）对象","uri":"/2.%E5%AF%B9%E8%B1%A1/"},{"categories":["redis"],"content":"三、列表对象 ","date":"2020-12-04","objectID":"/2.%E5%AF%B9%E8%B1%A1/:4:0","tags":["Redis","阅读"],"title":"《Redis设计与实现》（二）对象","uri":"/2.%E5%AF%B9%E8%B1%A1/"},{"categories":["redis"],"content":"3.1 编码方式 列表对象的编码可以是ziplist或者是linkedlist 如同前面提到的，压缩列表每个节点只保存一个列表元素。下面例子中，我们输入数字1，字符\"three\"，数字5。 redis \u003e RPUSH numbers 1 \"three\" 5 (integer) 3 如果使用的不是ziplist编码，而是linkedlist双端链表编码，那么 这其实是一个嵌套编码，Redis使用了一个StringObject来表示一个字符串对象，编码方式如同字符串对象的三种编码方式。如果编码对象是字符串值，展开后就是： ","date":"2020-12-04","objectID":"/2.%E5%AF%B9%E8%B1%A1/:4:1","tags":["Redis","阅读"],"title":"《Redis设计与实现》（二）对象","uri":"/2.%E5%AF%B9%E8%B1%A1/"},{"categories":["redis"],"content":"3.2 编码转换 当列表对象可以同时满足以下两个条件时，列表对象使用ziplist编码： 列表对象保存的所有字符串元素的长度都小于64字节； 列表对象保存的元素数量小于512个； 当上诉条件有一个不满足时，就会执行转换操作：原本保存在压缩列表里的所有列表元素都会被转移病保存到双端链表里面，对象的编码也会从ziplist变为linkedlist ","date":"2020-12-04","objectID":"/2.%E5%AF%B9%E8%B1%A1/:4:2","tags":["Redis","阅读"],"title":"《Redis设计与实现》（二）对象","uri":"/2.%E5%AF%B9%E8%B1%A1/"},{"categories":["redis"],"content":"四、哈希对象 ","date":"2020-12-04","objectID":"/2.%E5%AF%B9%E8%B1%A1/:5:0","tags":["Redis","阅读"],"title":"《Redis设计与实现》（二）对象","uri":"/2.%E5%AF%B9%E8%B1%A1/"},{"categories":["redis"],"content":"4.1 编码方式 哈希对象的编码可以是ziplist或者hashtable ziplist编码时，每当有新的键值对要加入到哈希对象时，程序会将保存了键的压缩列表节点推入到压缩列表表尾，然后再将保存了值的压缩列表节点推入到压缩列表表尾，因此： 保存了同一键值对的两个节点总是紧挨在一起，键前值后。 先添加到哈希对象中的键值对会被放在压缩列表的表头方向，而后来添加到哈希对象中的键值对会被放在压缩列表的表尾方向。 比如： redis\u003e HSET profile name \"Tom\" (integer) 1 redis\u003e HSET profile age 25 (integer) 1 redis\u003e HSET profile career \"Programmer\" (integer) 1 hashtable编码时，哈希对象中的每个键值对都使用一个字典键值对来保存： 字典的每个键都是一个字符串对象，对象中保存了键值对的键 字典的每个值都是一个字符串对象，对象中保存了键值对的值 比如，上面的例子改为hashtable编码 ","date":"2020-12-04","objectID":"/2.%E5%AF%B9%E8%B1%A1/:5:1","tags":["Redis","阅读"],"title":"《Redis设计与实现》（二）对象","uri":"/2.%E5%AF%B9%E8%B1%A1/"},{"categories":["redis"],"content":"4.2 编码转换 当哈希对象可以同时满足以下两个条件时，哈希对象使用ziplist编码： 哈希对象保存的所有键值对的键和值的字符串长度都小于64字节 哈希对象保存的键值对数量小于512个 类似于列表对象，不满足条件时，原本保存在压缩列表中的所有键值对都会被转移并保存到字典里面，对象的编码也会从ziplist变为hashtable ","date":"2020-12-04","objectID":"/2.%E5%AF%B9%E8%B1%A1/:5:2","tags":["Redis","阅读"],"title":"《Redis设计与实现》（二）对象","uri":"/2.%E5%AF%B9%E8%B1%A1/"},{"categories":["redis"],"content":"五、集合对象 ","date":"2020-12-04","objectID":"/2.%E5%AF%B9%E8%B1%A1/:6:0","tags":["Redis","阅读"],"title":"《Redis设计与实现》（二）对象","uri":"/2.%E5%AF%B9%E8%B1%A1/"},{"categories":["redis"],"content":"5.1 编码方式 集合对象的编码可以是intset或者hashtable intset编码时，元素将被密集得堆叠在位上，比如 redis \u003e SADD numbers 1 3 5 (integer) 3 另一方面，hashtable编码的集合对象使用字典作为底层实现，字典的每个键都是一个字符串对象，每个字符串对象包含了一个集合元素，而字典的值则全部设置为NULL ","date":"2020-12-04","objectID":"/2.%E5%AF%B9%E8%B1%A1/:6:1","tags":["Redis","阅读"],"title":"《Redis设计与实现》（二）对象","uri":"/2.%E5%AF%B9%E8%B1%A1/"},{"categories":["redis"],"content":"5.2 编码转换 当集合对象可以同时满足以下两个条件时，对象使用intset编码： 集合对象保存的所有元素都是整数值 集合对象保存的元素数量不超过512个 当使用 intset 编码所需的两个条件的任意一个不能被满足时， 对象的编码转换操作就会被执行： 原本保存在整数集合中的所有元素都会被转移并保存到字典里面， 并且对象的编码也会从 intset 变为 hashtable 。 ","date":"2020-12-04","objectID":"/2.%E5%AF%B9%E8%B1%A1/:6:2","tags":["Redis","阅读"],"title":"《Redis设计与实现》（二）对象","uri":"/2.%E5%AF%B9%E8%B1%A1/"},{"categories":["redis"],"content":"六、有序集合对象 ","date":"2020-12-04","objectID":"/2.%E5%AF%B9%E8%B1%A1/:7:0","tags":["Redis","阅读"],"title":"《Redis设计与实现》（二）对象","uri":"/2.%E5%AF%B9%E8%B1%A1/"},{"categories":["redis"],"content":"6.1 编码方式 有序集合的编码可以是ziplist或者skiplist。 ziplist编码的有序集合对象使用压缩列表作为底层实现，每个集合元素使用两个紧挨在一起的压缩列表节点来保存，第一个节点保存元素的成员(member)，第二个元素来保存元素的分值(score)。 redis\u003e ZADD price 8.5 apple 5.0 banana 6.0 cherry (integer) 3 skiplist编码的有序集合对象使用zset结构作为底层实现，一个zset结构同事包含一个字典和一个跳跃表： typedef struct zset{ zskiplist * zsl; dict * dict; }zset; 起作用主要是跳跃表，字典是辅助加速用。字典的键记录了元素的成员，而值保存了元素的分值。通过字典可以实现$O(1)$的查询时间复杂度。 有序集合每个元素的成员都是一个字符串对象， 而每个元素的分值都是一个double 类型的浮点数。 虽然 zset 结构同时使用跳跃表和字典来保存有序集合元素， 但这两种数据结构都会通过指针来共享相同元素的成员和分值， 所以同时使用跳跃表和字典来保存集合元素不会产生任何重复成员或者分值， 也不会因此而浪费额外的内存。 ","date":"2020-12-04","objectID":"/2.%E5%AF%B9%E8%B1%A1/:7:1","tags":["Redis","阅读"],"title":"《Redis设计与实现》（二）对象","uri":"/2.%E5%AF%B9%E8%B1%A1/"},{"categories":["redis"],"content":"6.2 编码转换 当有序集合对象可以同时满足以下两个条件时， 对象使用 ziplist 编码： 有序集合保存的元素数量小于 128 个； 有序集合保存的所有元素成员的长度都小于 64 字节； 不能满足以上两个条件的有序集合对象将使用 skiplist 编码。 ","date":"2020-12-04","objectID":"/2.%E5%AF%B9%E8%B1%A1/:7:2","tags":["Redis","阅读"],"title":"《Redis设计与实现》（二）对象","uri":"/2.%E5%AF%B9%E8%B1%A1/"},{"categories":["redis"],"content":"七、内存回收、对象共享、空转时长 对象中包括了一个引用计数器： typedef struct redisObject{ //引用计数 int refcount; }robj; 对象的引用计数信息会随着对象的使用状态而不断变化： 在创建一个新对象时， 引用计数的值会被初始化为 1 ； 当对象被引用时，计数值+1； 当对象不再被引用时，计数值-1； 当对象的引用计数值变为 0 时， 对象所占用的内存会被释放。 函数 作用 incrRefCount 将对象的引用计数增一 decrRefCount 讲对象的引用计数值减一，当对象的引用计数值等于0时，释放对象。 resetRefCount 将对象的引用计数值设置为0，但并不释放对象，这个函数通常在需要重新设置对象的引用计数值时使用 通过引用机制，还能实现对象共享。共享只针对整数值对象，不针对包含字符串的对象。 假设键A创建了一个包含整数值100的字符串对象作为值对象 如果这时键B也要创建一个同样保存了整数值100的字符串对象作为值对象，那么服务器有两种做法： 为键B新创建一个包含整数值100的字符串对象 让键A和键B共享一个字符串对象 以上两种方法很明显是第二种方法更节约内存。在Redis中，让多个键共享同一个值对象需要执行以下两个步骤， 将数据库键的值指针指向一个现有的值对象； 将被共享的值对象的引用计数增一； Redis会在初始化服务器的时候，创建一万个字符串对象，这些对象包含了从0~9999的所有整数值，当服务器需要用到值为0~9999的字符串对象时，服务器就会使用这些共享对象，而不是新建对象。 为什么Redis不共享字符串的对象？ 共享对象 复杂度 保存整数值字符串对象 $O(1)$ 保存字符串值的字符串对象 $O(N)$ 包含了多个值的对象（列表或哈希） $O(N^2)$ redisObject结构包含的最后一个属性为lru属性，该属性记录了对象最后一次被命令程序访问的时间： typedef struct redisObject{ unsigned lru :22; }robj; OBJECT IDLETIME 命令可以打印出给定键的空转时长， 这一空转时长就是通过将当前时间减去键的值对象的 lru 时间计算得出的： redis\u003e SET msg \"hello world\" OK # 等待一小段时间 redis\u003e OBJECT IDLETIME msg (integer) 20 注意OBJECT IDLETIME命令的实现是特殊的，这个命令在访问键的值对象时，不会修改值对象的lru属性。 当内存满时，空转时长较长的键会被优先释放。 ","date":"2020-12-04","objectID":"/2.%E5%AF%B9%E8%B1%A1/:8:0","tags":["Redis","阅读"],"title":"《Redis设计与实现》（二）对象","uri":"/2.%E5%AF%B9%E8%B1%A1/"},{"categories":["协议"],"content":"Protobuf是什么？ Protobuf是Google开发的一种数据描述语言，能够将结构化数据序列化，可用于数据存储、通信协议等方面。 可以理解为更快的、更简单、更小的JSON或XML，区别在于Protocol Buffers是二进制，而JSON和XML是文本格式。 ","date":"2020-12-01","objectID":"/protobuf/:1:0","tags":["协议"],"title":"Protobuf介绍","uri":"/protobuf/"},{"categories":["协议"],"content":"Protobuf应用场景 Protobuf可以用于结构化数据串行化（序列化）。很适合做数据存储或RPC数据交换格式。可用于通讯协议、数据存储等领域的语言无关、平台无关、可扩展的序列化结构数据格式。 ","date":"2020-12-01","objectID":"/protobuf/:2:0","tags":["协议"],"title":"Protobuf介绍","uri":"/protobuf/"},{"categories":["协议"],"content":"Protobuf优缺点 为什么有了XML和JSON等已经很普遍的数据传输方式，还要设计出Protobuf这种新的协议呢？ ","date":"2020-12-01","objectID":"/protobuf/:3:0","tags":["协议"],"title":"Protobuf介绍","uri":"/protobuf/"},{"categories":["协议"],"content":"优点 性能好/效率高 时间维度：采用XML格式对数据进行序列化时，时间消耗上性能尚可。但使用XML格式对数据进行反序列化时的时间花费上，耗时长，性能差。 空间维度：XML格式为了保持较好的可读性，引入了一些冗余的文本信息。所以在使用XML格式进行存储时，也会消耗空间。 整体而言：Prtobuf以高效的二进制方式存储，比XML小3到10倍，快20到100倍。 代码生成机制 代码生成机制的含义： 在GO语言中，可以通过定义结构体封装描述一个对象，并构造一个新的结构体对象。比如定义一个Person结构体，并定义一个Person.go的文件 type Person struct{ Name string Sex int Age int } 在分布式系统中，因为程序代码分开部署，比如A,B。A系统在调用B系统时，无法直接采用代码的形式进行调用，因为A系统中不存在B系统中的代码。因此，A系统只负责将调用和通信的数据以二进制数据包的形式传递给B系统，由B系统根据获取到的数据包，自己构建出对应的数据对象，生成数据对象定义代码文件。这种利用编译器，根据数据文件自动生成结构体定义和相关方法文件的机制叫做代码生成机制。 代码生成机制的优点 首先，代码生成机制能够极大的解放开发者编写数据协议解析过程的时间，提高工作效率； 其次，易于开发者维护和迭代，当需求发生变更时，开发者只需要修改对应的数据传输文件内容即可完成所有的修改。 支持向后兼容和向前兼容 向后兼容 在软件开发迭代和升级过程中，“后”可以理解为新版本，越新的版本越靠后。“前”意味着早起的版本或者先前的版本。向后兼容就是系统升级迭代后，仍然可以处理老版本的数据业务逻辑 向前兼容 向前兼容是系统代码未升级，但是接受到了新的数据，此时老版本生成的系统代码可以处理接收到的新类型的数据。 支持前后兼容是非常重要的一个特点，在庞大的系统开发中，往往不可能统一完成所有模块的升级，为了保证系统功能正常不受影响，应最大限度保证通讯协议的向前兼容和向后兼容。 支持多种编程语言 Protobuf作为Google开源的一种数据协议，还有很多种的语言版本。在Google官方发布的Protobuf的源代码中包含了C++、Java、Python三种语言。 ","date":"2020-12-01","objectID":"/protobuf/:3:1","tags":["协议"],"title":"Protobuf介绍","uri":"/protobuf/"},{"categories":["协议"],"content":"缺点 可读性较差 为了提高性能，Protobuf采用了二进制格式进行编码。二进制格式编码对开发者来说是没办法进行阅读的。在进行程序调试的时候，比较困难。 缺乏自描述 比如XML语言是一种自描述的标记语言，即字段标记的同时就表达了内容对应的含义。而Protobuf不是一种自描述语言，开发者对于二进制格式的Protobuf，没有办法知道所对应的真实的数据结构，在使用Protobuf协议传输时，必须配备对应的proto配置文件。 ","date":"2020-12-01","objectID":"/protobuf/:3:2","tags":["协议"],"title":"Protobuf介绍","uri":"/protobuf/"},{"categories":["协议"],"content":"Protobuf协议语法 ","date":"2020-12-01","objectID":"/protobuf/:4:0","tags":["协议"],"title":"Protobuf介绍","uri":"/protobuf/"},{"categories":["协议"],"content":"Protobuf的协议的格式 Protobuf协议规定：使用该协议进行序列化和反序列化操作时，首先定义传输数据的格式，并命名以\".proto\"为扩展名定义消息定义文件 ","date":"2020-12-01","objectID":"/protobuf/:4:1","tags":["协议"],"title":"Protobuf介绍","uri":"/protobuf/"},{"categories":["协议"],"content":"Message定义一个消息 例如： message Order{ required string order_id = 1; repeated int64 num = 2; optional int32 timestamp = 3;} 指定字段类型： 在proto协议中，字段的类型包括字符串(string)、整形(int32、int64)、枚举(enum)等类型 分配标识符： 在消息字段中，每个字段都有一个唯一的标识符。最小的标识号可以从1开始，最大到536870911。不可以使用其中的[19000-19999]的标识号，Protobuf协议实现中对这些进行了预留。如果非要在.proto文件中使用这些预留标识号，编译时就会报警。 指定字段规则： 字段的修饰符包含三种类型，分别是 required： 表示该值是必须要设置的。 optional： 消息格式中该字段可以有0个或1个值（不超过1个） repeated： 表示该值可以重复，相当于Go中的slice。 ","date":"2020-12-01","objectID":"/protobuf/:4:2","tags":["协议"],"title":"Protobuf介绍","uri":"/protobuf/"},{"categories":["协议"],"content":"使用Protobuf的步骤 ","date":"2020-12-01","objectID":"/protobuf/:5:0","tags":["协议"],"title":"Protobuf介绍","uri":"/protobuf/"},{"categories":["协议"],"content":"创建 创建扩展名为.proto的文件，并编写代码。比如创建person.proto文件，内容如下 syntax = \"proto2\" // 协议版本 package examplemessage Person{ required string Name = 1; required int32 Age = 2; required string From = 3;} ","date":"2020-12-01","objectID":"/protobuf/:5:1","tags":["协议"],"title":"Protobuf介绍","uri":"/protobuf/"},{"categories":["协议"],"content":"编译 编译.proto文件，生成Go语言文件。执行如下命令： protoc --go_out =生成路径 文件路径 ","date":"2020-12-01","objectID":"/protobuf/:5:2","tags":["协议"],"title":"Protobuf介绍","uri":"/protobuf/"},{"categories":["协议"],"content":"使用 package main import ( \"beegodemo/proto\" \"fmt\" proto2 \"github.com/golang/protobuf/proto\" \"log\" ) func main() { student := \u0026proto.Student{ Name: \"lly\", Age: 12, } data,err := proto2.Marshal(student) if err != nil{ log.Fatal(err) } stu := \u0026proto.Student{} err = proto2.Unmarshal(data,stu) if err != nil { log.Fatal(err) } fmt.Println(stu) } ","date":"2020-12-01","objectID":"/protobuf/:5:3","tags":["协议"],"title":"Protobuf介绍","uri":"/protobuf/"},{"categories":["协议"],"content":"执行 go build -o hello.exe hello.exe ","date":"2020-12-01","objectID":"/protobuf/:5:4","tags":["协议"],"title":"Protobuf介绍","uri":"/protobuf/"}]